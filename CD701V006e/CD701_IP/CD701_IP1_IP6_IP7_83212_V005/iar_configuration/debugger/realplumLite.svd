<?xml version="1.0" encoding="utf-8"?>
<!-- ============================================================================ -->
<device xmlns:xs="http://www.w3.org/2001/XMLSchema-instance" schemaVersion="1.1" xs:noNamespaceSchemaLocation="CMSIS-SVD_Schema_1_1.xsd">
  <IndieMicro></IndieMicro>
  <name>IND83212</name>
  <series>Verne</series>
  <version>B0</version>
  <description>Wuxi IndieMicro </description>
  <cpu>
    <name>CM0</name>
    <revision>r0p1</revision>
    <endian>selectable</endian>
    <mpuPresent>false</mpuPresent>
    <fpuPresent>false</fpuPresent>
    <nvicPrioBits>4</nvicPrioBits>
    <vendorSystickConfig>false</vendorSystickConfig>
  </cpu>
  <addressUnitBits>8</addressUnitBits>
  <width>32</width>
  <peripherals>
    <peripheral>
      <name>CRGA</name>
      <version>B0</version>
      <description>Clock &amp; Reset Generator</description>
      <groupName>CRGA</groupName>
      <prependToName>CRGA_</prependToName>
      <baseAddress>0x50000000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x0040</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>LFCLKCTRL</name>
          <description>Low frequency clock control</description>
          <addressOffset>0x00000000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>LFRCSTS</name>
              <description>Slow oscillator status. Will be high when the Low Frequency oscillator is selected</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CLKLFSEL</name>
              <description>LF Clock Source select. Used to select lf osc mode between
0x0: CLK_LF(LF OSC out) is 256KHz, slow system clock freq is Freq_CLK_LF/2 = 128KHz.
0x1: CLK_LF(LF OSC out) is 256KHz, slow system clock freq is Freq_CLK_LF/16= 16KHz.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SYSCLKCTRL</name>
          <description>System clock control.</description>
          <addressOffset>0x00000004</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>HFRCENA</name>
              <description>Fast oscillator enable. Setting this bit when the High Frequency oscillator is not running will cause the oscillator to start (the PMU may have already started it). Even though the fast oscillator is running, its output is only used when selected via the clock mux - see CLKSEL. This bit is cleared automatically on entering SLEEP mode</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HFRCSTS</name>
              <description>Fast oscillator status. Will be high when High Frequency oscillator is enabled</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>SYSCLKSEL</name>
              <description>Clock select. Used to switch between the fast and slow system clocks
0x0: Slow clock
0x1: Fast clock</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIVSYSCLK</name>
              <description>Clock div select. Select the divider ratio on the system clock when using fast oscillator
0x0: No Division. Full Clock speed.
0x1: Div by 2.
0x2: Div by 3.
0x3: Div by 4.
0x4: Div by 5.
0x5: Div by 6.
0x6: Div by 7.
0x7: Div by 8.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>HF_RC_LDO_VSEL</name>
              <description>16MHz RC OSC LDO output select.
0x0: 1V45 Selected
0x1: 1V50 Selected
0x2: 1V55 Selected
0x3: 1V65 Selected</description>
              <bitOffset>20</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RESETCTRL</name>
          <description>Reset control</description>
          <addressOffset>0x00000008</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>PORFLAG</name>
              <description>Power on reset flag. Set by the hardware during power-on reset</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>OVFLAG</name>
              <description>Over Voltage Monitor flag. Set by the hardware when the over voltage monitor.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>BOR3V3FLAG</name>
              <description>BOR 3v3 flag. Set by the hardware when a brownout of the 3.3V supply is detected.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>UVFLAG</name>
              <description>Under Voltage Monitor flag. Set by the hardware when the under voltage monitor.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>BOR1V5FLAG</name>
              <description>BOR 1v5 flag. Set by the hardware when a brownout of the 1.5V supply is detected.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>WDTFLAG</name>
              <description>Watchdog bark flag. Set by the hardware when the watchdog barks.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>OVTEMPFLAG</name>
              <description>Over Temp Violation flag. Set by the hardware when the over temp condition is detected.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PORFLAGCLR</name>
              <description>POR flag clear. Set to clear the POR flag</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>OVFLAGCLR</name>
              <description>OV flag clear. Set to clear the OV flag</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>BOR3V3FLAGCLR</name>
              <description>BOR 3v3 clear. Set to clear the 3.3V brownout detected flag</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>UVFLAGCLR</name>
              <description>UV flag clear. Set to clear the UV flag</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>BOR1V5FLAGCLR</name>
              <description>BOR 1v5 clear. Set to clear the 1.5V brownout detected flag</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>WDTFLAGCLR</name>
              <description>WDT flag clear. Set to clear the WDT flag</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>OVTEMPFLAGCLR</name>
              <description>OVTEMP flag clear. Set to clear the OVTEMP flag</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>HARDRSTREQ</name>
              <description>	Hard reset request. Set to trigger a hard reset of chip</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>SAFEMODEREQ</name>
              <description>Safe Mode request. Set to force chip into Safe Mode, in which Chip can only be wakeup by POR.Configure with writting debug key of SYSCTRL_SFRS-&gt;DEBUG_ACCESS_KEY.
Autoclear: includes a synchronous reset signal which clears the register on the cycle following write.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>SAFEMODEENA</name>
              <description>Safe Mode enable. Set to enable safe Mode.Configure with writting debug key of SYSCTRL_SFRS-&gt;DEBUG_ACCESS_KEY.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SOFTRSTREQ</name>
              <description>Soft reset request. Set to trigger a soft reset of chip
Autoclear: includes a synchronous reset signal which clears the register on the cycle following write.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MODULERST</name>
          <description>Module Reset control</description>
          <addressOffset>0x0000000C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>MODULERSTREQ</name>
              <description>Module Soft reset request. Set to trigger a soft reset of module below.
0x1: ADC Soft reset request
0x2: LINS Soft reset request
0x4: PWM soft reset request
0x8: PWM AUX soft reset request
Autoclear: includes a synchronous reset signal which clears the register on the cycle following write.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>BORACTION</name>
          <description>BOR action</description>
          <addressOffset>0x000000010</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>VDD3V3</name>
              <description>BOR 3v3 action. Defines the consequences of brown-out condition on the 3v3 supply being detected by the hardware. Configure with writting trim key
0x1: IRQ generated
0x0: Hard reset generated</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VDD1V5</name>
              <description>BOR 1v5 action. Defines the consequences of brown-out condition on the 1v5 supply being detected by the hardware. Configure with writting trim key
0x1: IRQ generated
0x0: Hard reset generated</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>BOR_3V3_LOCK</name>
              <description>Set Only bit. Set this bit to lock BOR_3V3_ACTION &amp; S_BOR_3V3 bits.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BOR_1V5_LOCK</name>
              <description>Set Only bit. Set this bit to lock BOR_1V5_ACTION &amp; S_BOR_1V5 bits.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>BORCONFIG</name>
          <description>BOR configuration</description>
          <addressOffset>0x000000014</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>S_BOR_3P3V</name>
              <description>BOR 3v3 threshold. Select the BOR threshold voltage level for the 3v3 regulator, Following typical value can be used as reference:
NOTE: The write operation of this register takes effect by PMU_SFRS-&gt;CTRL.UPDATE and write trim key
0x0: Vr: 2.223 V, Vf: 2.163 V,
0x1: Vr: 2.288 V, Vf: 2.228 V,
0x2: Vr: 2.358 V, Vf: 2.293 V,
0x3: Vr: 2.428 V, Vf: 2.363 V,
0x4: Vr: 2.503 V, Vf: 2.433 V,
0x5: Vr: 2.583 V, Vf: 2.513 V,
0x6: Vr: 2.668 V, Vf: 2.598 V,
0x7: Vr: 2.763 V, Vf: 2.688 V,
0x8: Vr: 2.858 V, Vf: 2.783 V,
0x9: Vr: 2.968 V, Vf: 2.883 V,
0xa: Vr: 3.078 V, Vf: 2.998 V,
0xb: Vr: 3.203 V, Vf: 3.118 V,
0xc: Vr: 3.338 V, Vf: 3.248 V,
0xd: Vr: 3.483 V, Vf: 3.388 V,
0xe: Vr: 3.638 V, Vf: 3.543 V,
0xf: Vr: 3.813 V, Vf: 3.708 V,</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>S_BOR_1P5V</name>
              <description>BOR 1v5 threshold. Select the BOR threshold voltage level for the 1v5 regulator. Following typical value can be used as reference:
NOTE: The write operation of this register takes effect by PMU_SFRS-&gt;CTRL.UPDATE and write trim key
0x0: Vr: 1.243 V, Vf: 1.218 V,
0x1: Vr: 1.273 V, Vf: 1.243 V,
0x2: Vr: 1.298 V, Vf: 1.273 V,
0x3: Vr: 1.328 V, Vf: 1.298 V,
0x4: Vr: 1.358 V, Vf: 1.328 V,
0x5: Vr: 1.393 V, Vf: 1.363 V,
0x6: Vr: 1.428 V, Vf: 1.393 V,
0x7: Vr: 1.463 V, Vf: 1.428 V,
0x8: Vr: 1.498 V, Vf: 1.468 V,
0x9: Vr: 1.538 V, Vf: 1.503 V,
0xa: Vr: 1.583 V, Vf: 1.548 V,
0xb: Vr: 1.623 V, Vf: 1.588 V,
0xc: Vr: 1.673 V, Vf: 1.633 V,
0xd: Vr: 1.718 V, Vf: 1.683 V,
0xe: Vr: 1.773 V, Vf: 1.733 V,
0xf: Vr: 1.828 V, Vf: 1.788 V,</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>BORDEGLITCH</name>
          <description>BOR Deglitch, NOTE: The write operation of this register takes effect by PMU_SFRS-&gt;CTRL.UPDATE and write trim key</description>
          <addressOffset>0x000000018</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>ENA_BOR1V5_DEGLITCH</name>
              <description>enable of BOR1V5 deglitch.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SEL_BOR1V5_NEG_DEGLITCH</name>
              <description>select the deglitch width of BOR1V5 negedge.
0x0: 16us Selected
0x1: 32us Selected
0x2: 64us Selected
0x3: 128us Selected</description>
              <bitOffset>4</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SEL_BOR1V5_POS_DEGLITCH</name>
              <description>select the deglitch width of BOR1V5 posedge.
0x0: 16us Selected
0x1: 32us Selected
0x2: 64us Selected
0x3: 128us Selected</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ENA_BOR3V3_DEGLITCH</name>
              <description>enable of BOR3V3 deglitch.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SEL_BOR3V3_NEG_DEGLITCH</name>
              <description>select the deglitch width of BOR3V3 negedge.
0x0: 16us Selected
0x1: 32us Selected
0x2: 64us Selected
0x3: 128us Selected</description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SEL_BOR3V3_POS_DEGLITCH</name>
              <description>select the deglitch width of BOR3V3 posedge.
0x0: 16us Selected
0x1: 32us Selected
0x2: 64us Selected
0x3: 128us Selected</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WDTACTION</name>
          <description>Watchdog action</description>
          <addressOffset>0x00000001C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>WDTACTION</name>
              <description>Watchdog action. Defines the consequences of watchdog bark being detected by the hardware.
0x0: IRQ generated
0x1: Hard reset generated</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WDTBARKCNT</name>
              <description>WatchDog Bark Counter. Read to reflect the WDT bark counter value.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>WDTBARKCNTCLR</name>
              <description>WatchDog Bark Counter Clear. Set to clear watchdog bark counter.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LFCLKKILL</name>
          <description>Low frequency clock kill</description>
          <addressOffset>0x000000020</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>KILLLFRC</name>
              <description>Kill slow RC oscillator. Setting this bit gates the low frequency RC oscillator input.Configure with writting debug key of SYSCTRL_SFRS-&gt;DEBUG_ACCESS_KEY.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OVTEMPACTION</name>
          <description>OVTEMP action</description>
          <addressOffset>0x000000024</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>OVTEMP</name>
              <description>Over Temperature action. Defines the consequences of over temp condition detected by the hardware.
0x2: No action
0x1: IRQ generated
0x0: Hard reset generated</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OVTEMP_LOCK</name>
              <description>Set Only bit. Set this bit to lock OVTEMP related bits.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OVTEMPCONFIG</name>
          <description>OVTEMP configuration</description>
          <addressOffset>0x000000028</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>VTEMP_SEL</name>
              <description>Over Temp protect threshold temp trim. Select the OVTEMP threshold level for the monitor.The write operation of this register takes effect by PMU_SFRS-&gt;CTRL.UPDATE .
0x0: Rising: 93.13-Deg; Falling: 79.13-Deg
0x1: Rising: 98.13-Deg; Falling: 84.13-Deg
0x2: Rising: 103.6-Deg; Falling: 89.13-Deg
0x3: Rising: 109.1-Deg; Falling: 94.13-Deg
0x4: Rising: 115.1-Deg; Falling: 99.63-Deg
0x5: Rising: 121.1-Deg; Falling: 105.1-Deg
0x6: Rising: 127.1-Deg; Falling: 111.1-Deg
0x7: Rising: 133.1-Deg; Falling: 117.1-Deg
0x8: Rising: 139.6-Deg; Falling: 123.1-Deg
0x9: Rising: 146.6-Deg; Falling: 129.6-Deg
0xa: Rising: 153.6-Deg; Falling: 136.1-Deg
0xb: Rising: 160.6-Deg; Falling: 142.6-Deg
0xc: Rising: 168.1-Deg; Falling: 149.6-Deg
0xd: Rising: 176.6-Deg; Falling: 157.1-Deg
0xe: Rising: 185.1-Deg; Falling: 164.6-Deg
0xf: Rising: 195.6-Deg; Falling: 172.6-Deg</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERTEMP_EN</name>
              <description>OverTemp Monitor Enable bit.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TEMPSENSE_EN</name>
              <description>enable Temp Sensor Analog Part. Set to enable Temperature Sensor analog circuit.
NOTE: The write operation of this register takes effect by IOCTRL_SFRS-&gt;LIN.UPDATE</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OVUVACTION</name>
          <description>OVUV action</description>
          <addressOffset>0x00000002C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>OV_ACTION</name>
              <description>Over Voltage action. Defines the consequences of over voltage condition detected by the hardware.
0x1: No action
0x0: Hard reset generated</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UV_ACTION</name>
              <description>Under Voltage action. Defines the consequences of under voltage condition detected by the hardware.
0x1: No action
0x0: Hard reset generated</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OV_LOCK</name>
              <description>Set Only bit. Set this bit to lock OV ACTION related bits.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UV_LOCK</name>
              <description>Set Only bit. Set this bit to lock UV ACTION related bits.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PMUA</name>
      <version>B0</version>
      <description>Power Management Unit</description>
      <groupName>PMUA</groupName>
      <prependToName>PMUA_</prependToName>
      <baseAddress>0x50000040</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x0020</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTRL</name>
          <description>Control</description>
          <addressOffset>0x00000000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>HIBERNATE</name>
              <description>Hibernate. Set to put the chip into HIBERATE mode. Before setting this bit, ensure that wake interrupt controller HOLD bit has been set (and that a corresponding Lullaby interrupt has been received).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>FASTBOOT</name>
              <description>Fast boot. Set to enable used of the fast clock during subsequent power-up sequences (including the portion consumed by the Clough boot sequence). The set value brings the system up with the slow clock to make the initial boot and any boot after a hard reset (e.g. after a brownout) as safe as possible.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BG_OK</name>
              <description>the flag of bandgap OK. the flag of bandgap OK</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DBG_EN_LOWIQ</name>
              <description>Set to enable of low power mode for BG_TOP at PMU debug mode.
NOTE: The write operation of this register takes effect by PMU_SFRS-&gt;CTRL.UPDATE at PMU debug mode</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DBG_DIS_BG_UVLO</name>
              <description>Set to disable of low power mode for UVLO in BG_TOP at PMU debug mode.
NOTE: The write operation of this register takes effect by PMU_SFRS-&gt;CTRL.UPDATE at PMU debug mode</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DBG_EN_LP_CAPLESS</name>
              <description>1.5V ldo low power mode, set 1 to enter low power at PMU debug mode.
NOTE: The write operation of this register takes effect by PMU_SFRS-&gt;CTRL.UPDATE at PMU debug mode</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VDD1V5_LDO_CHOOSE</name>
              <description>1.5V LDO Mode selection.
NOTE: This register is not used by Analog PMU
0x0: choose Capless LDO
0x1: choose Caps LDO</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OPT_EN_LOWIQ</name>
              <description>Set to enable of low power mode for BG_TOP at Deepsleep Mode.
NOTE: The write operation of this register takes effect by PMU_SFRS-&gt;CTRL.UPDATE at Trim mode</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OPT_EN_LP_CAPLESS</name>
              <description>1.5V ldo low power mode, set 1 to enter low power at Deepsleep mode.
NOTE: The write operation of this register takes effect by PMU_SFRS-&gt;CTRL.UPDATE at Trim mode</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IGNORE_CIFS</name>
              <description>Ignore QACKs. Setting a bit in this register prevents PMUA from waiting for the assertion of the corresponding 'Quiescent State Acknowlege' signal when before transitioning towards the Hibernate state.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DBG_TEST</name>
              <description>PRE5V DBG mode enable. Set 1, Pre5V voltage can output through 3P3V LDO pin(DBG_DIS_LDO_3V3 = 1'b0 for enable 3v3-LDO).</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DBG_DISCHARGE_1V5</name>
              <description>1V5 LDO Debug Mode:
a. Set '0' to test 1V5-LDO function;
b. Set '1' to test 1V5-LDO Discharge Circuit.
NOTE: The write operation of this register takes effect by PMU_SFRS-&gt;CTRL.UPDATE at PMU debug mode</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DBG_DISCHARGE_3V3</name>
              <description>3V3 LDO Debug Mode:
a. Set '0' to test 3V3-LDO function;
b. Set '1' to test 3V3-LDO Discharge Circuit.
NOTE: The write operation of this register takes effect by PMU_SFRS-&gt;CTRL.UPDATE at PMU debug mode</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PD1V5_ENA_HIBERNATE</name>
              <description>enable of 1V5 Power Domain at Hibernate mode. set to enable the 1V5 Power Domain at Hibernate mode, this mode is defined as DEEPSLEEP mode.
NOTE: The write operation of this register takes effect by PMU_SFRS-&gt;CTRL.UPDATE at PMU debug mode</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DBG_DIS_CP</name>
              <description>Set 1, Shut down PRE5V ChargePump, PRE5V=Vzener-Vgs. Only take effect at Debug mode(DBG_TEST = 1) at PMU debug mode</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DBG_DIS_LDO_3V3</name>
              <description>NOTE:Don't use.Debug Contrl of dis_ldo_3v3 at PMU debug mode.
NOTE: The write operation of this register takes effect by PMU_SFRS-&gt;CTRL.UPDATE at PMU debug mode</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DBG_DIS_LDO_1V5</name>
              <description>Debug Contrl of dis_ldo_1v5 at PMU debug mode.(Not Use)
NOTE: The write operation of this register takes effect by PMU_SFRS-&gt;CTRL.UPDATE at PMU debug mode</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DBG_DIS_BOR_3V3</name>
              <description>Debug Contrl of dis_bor_3v3 at PMU debug mode.
NOTE: The write operation of this register takes effect by PMU_SFRS-&gt;CTRL.UPDATE at PMU debug mode</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DBG_DIS_BOR_1V5</name>
              <description>Debug Contrl of dis_bor_1v5 at PMU debug mode.
NOTE: The write operation of this register takes effect by PMU_SFRS-&gt;CTRL.UPDATE at PMU debug mode</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DBG_ISO</name>
              <description>NOTE:Don't use. Debug Contrl of isolation of domain 1V5 to domain PRE5V at PMU debug mode.
NOTE: The write operation of this register takes effect by PMU_SFRS-&gt;CTRL.UPDATE at PMU debug mode</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UPDATE</name>
              <description>PMUA Configure Update. Set to update the Configurations to PRE5V domains.
NOTE: DO NOT change the CTRL register when it is high, which indicates there is an update in progress, It gets cleared by the core when the current update is done</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>dual</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMUTRIM</name>
          <description>PMU Trim Register</description>
          <addressOffset>0x00000004</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>OCP_CTRL_1V5</name>
              <description>OCP trim for 1.5V LDO(default 30mA) .The write operation of this register takes effect by PMU_SFRS-&gt;CTRL.UPDATE at PMU debug mode.
0x0: 20.0 mA
0x1: 22.5 mA
0x2: 25.0 mA
0x3: 27.5 mA
0x4: 30.0 mA
0x5: 32.5 mA
0x6: 35.0 mA
0x7: 37.5 mA
0x8: 40.0 mA
0x9: 42.5 mA
0xa: 45.0 mA
0xb: 47.5 mA
0xc: 50.0 mA
0xd: 52.5 mA
0xe: 55.0 mA
0xf: 57.5 mA</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OCP_CTRL_3V3</name>
              <description>OCP trim for 3P3V LDO(default 30mA) .The write operation of this register takes effect by PMU_SFRS-&gt;CTRL.UPDATE at PMU debug mode.
0x0: 10.0 mA
0x1: 12.5 mA
0x2: 15.0 mA
0x3: 17.5 mA
0x4: 20.0 mA
0x5: 22.5 mA
0x6: 25.0 mA
0x7: 27.5 mA
0x8: 30.0 mA
0x9: 32.5 mA
0xa: 35.0 mA
0xb: 37.5 mA
0xc: 40.0 mA
0xd: 42.5 mA
0xe: 45.0 mA
0xf: 47.5 mA</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIM_VREF_BUF</name>
              <description>Trim the buffer refernce voltage include VREF_1/VREF_1P1/VREF_0P75/VREF_0P6.
(1) The voltage range before trimming is 1.19825V ~ 1.237V.
(2) The step is 1.25mV, and the precision of trimming is +- 0.625mV.
(3) The voltage is 1.217V while TRIM_VREF_BUF == 0x0.
The write operation of this register takes effect by PMU_SFRS-&gt;CTRL.UPDATE at PMU debug mode</description>
              <bitOffset>8</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIM_BG</name>
              <description>Trim BandGap.
(1) The voltage range before trimming is 1.16797V ~ 1.26337V.
(2) The trim ratio 1/1.4811.
(3) The voltage is 1.21455V while TRIM_BG == 0x0.
The write operation of this register takes effect by PMU_SFRS-&gt;CTRL.UPDATE at PMU debug mode</description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VDD1V5_LDO_TRIM</name>
              <description>1.5V LDO output trim. The write operation of this register takes effect by PMU_SFRS-&gt;CTRL.UPDATE at PMU debug mode
0x0: 1.55V
0x1: 1.61V
0x2: 1.65V
0x3: 1.69V</description>
              <bitOffset>24</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VDD3V3_LDO_TRIM</name>
              <description>3.3V LDO output trim.The write operation of this register takes effect by PMU_SFRS-&gt;CTRL.UPDATE at PMU debug mode
0x0: 3.40V
0x1: 3.00V
0x2: 3.09V
0x3: 3.18V
0x4: 3.28V
0x5: 3.52V
0x6: 3.65V
0x7: 3.80V</description>
              <bitOffset>28</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DWELL</name>
          <description>Dwell</description>
          <addressOffset>0x00000008</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>ENABLE_1V5</name>
              <description>Enable 1.5V dwell time. Defines the amount of time spent in the 'Enable 1V5' state. Allows 3v3 and 1v5 regs to settle.at PMU debug mode</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ATTACH_1V5</name>
              <description>Attach 1.5V dwell time. Defines the amount of time spent in the 'Attach 1V5' state. State Attaches 1.5V to MCU.at PMU debug mode</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ATTACH_3V3</name>
              <description>Attach 3.3V dwell time. Defines the amount of time spent in the 'Attach 3V3' state. State Attaches 3.3V to MCU.at PMU debug mode</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>POWER_DOWN_MCU</name>
              <description>Power down MCU dwell time. Defines the amount of time spent in the 'Power down MCU' state. Pausing here allows the MCU supplies to discharge (to guarantee subsequent POR).at PMU debug mode</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>VBATCTRL</name>
          <description>VBAT Monitor Register</description>
          <addressOffset>0x0000000C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>BAT_UV_EN</name>
              <description>Battery Under Voltage Monitor Enable. Set to enable the vbat under voltage monitor analog comparator circuit.The write operation of this register takes effect by PMU_SFRS-&gt;CTRL.UPDATE</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BAT_OV_EN</name>
              <description>Battery Over Voltage Monitor Enable. Set to enable the vbat over voltage monitor analog comparator circuit.The write operation of this register takes effect by PMU_SFRS-&gt;CTRL.UPDATE</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UV_POL</name>
              <description>Battery Voltage Monitor Under Voltage Interrupt Event Polarity. Flips the under voltage event signal coming from the analog comparator circuit which feeds into the interrupt generator.
0x0: Native Polarity
0x1: Flip Polarity</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OV_POL</name>
              <description>Battery Voltage Monitor Over Voltage Interrupt Event Polarity. Flips the over voltage event signal coming from the analog comparator circuit which feeds into the interrupt generator.
0x0: Native Polarity
0x1: Flip Polarity</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LOW</name>
              <description>Battery Voltage Low Status. RAW battery monitor under voltage event signal coming from the analog comparator circuit.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>HIGH</name>
              <description>Battery Voltage High Status. RAW battery monitor over voltage event signal coming from the analog comparator circuit.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>LOW_DBNC</name>
              <description>Battery Voltage Low Status after debouncing. Battery monitor under voltage event signal coming from the debouncer of analog comparator circuit.</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>HIGH_DBNC</name>
              <description>Battery Voltage High Status after deboucing. Battery monitor over voltage event signal coming from the debouncer of analog comparator circuit.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>VBATTRIM</name>
          <description>VBAT Monitor Trim Register</description>
          <addressOffset>0x000000010</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>UVLEVEL</name>
              <description>Battery Voltage Monitor Under Voltage Select. Selects the reference level for the Under Voltage monitor. If UVLEVEL[5:3]&gt;0x04, the actual analog trim value is the same as UVLEVEL=0x0A. The UVLEVEL threshold is mononically increased with the setting.The write operation of this register takes effect by PMU_SFRS-&gt;CTRL.UPDATE
0x0: Vf: 4.615V
0x1: Vf: 4.685V
0x7: Vf: 5.135V
0x8: Vf: 5.225V
0x9: Vf: 5.135V
0xa: Vf: 5.405V
0xf: Vf: 5.895V
0x10: Vf: 6.015V
0x11: Vf: 6.125V
0x17: Vf: 6.925V
0x18: Vf: 7.075V
0x19: Vf: 7.235V
0x1f: Vf: 8.385V
0x20: Vf: 8.605V
0x21: Vf: 8.845V
0x27: Vf:10.610V</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UVHYS</name>
              <description>Battery Voltage Monitor Under Voltage Hysterisis Select. Selects the hysterisis level for the Under Voltage monitor.The write operation of this register takes effect by PMU_SFRS-&gt;CTRL.UPDATE
0x0: 0.475V
0x1: 0.835V
0x2: 1.225V
0x3: 1.635V</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OVLEVEL</name>
              <description>Battery Voltage Monitor Over Voltage Select. Selects the reference level for the Over Voltage monitor to output one-hot Configuration to Analog Module.(If OVLEVEL&gt;9, the actual analog trim value is the same as default value:OVLEVEL=0x07).The write operation of this register takes effect by PMU_SFRS-&gt;CTRL.UPDATE
0x0: Over Voltage Threshold- 10'h001: 14.75V
0x1: Over Voltage Threshold- 10'h002: 15.18V
0x2: Over Voltage Threshold- 10'h004: 15.65V
0x3: Over Voltage Threshold- 10'h008: 16.37V
0x4: Over Voltage Threshold- 10'h010: 16.85V
0x5: Over Voltage Threshold- 10'h020: 17.57V
0x6: Over Voltage Threshold- 10'h040: 18.30V
0x7: Over Voltage Threshold- 10'h080: 19.00V
0x8: Over Voltage Threshold- 10'h100: 19.97V
0x9: Over Voltage Threshold- 10'h200: 20.70V</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OVHYS</name>
              <description>Battery Voltage Monitor Over Voltage Hysterisis Select. Selects the hysterisis level for the Over Voltage monitor.The write operation of this register takes effect by PMU_SFRS-&gt;CTRL.UPDATE
0x0: 0.359V
0x1: 0.720V
0x2: 1.080V
0x3: 1.440V</description>
              <bitOffset>24</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>VBATDBNC</name>
          <description>VBAT Debounce Register</description>
          <addressOffset>0x000000014</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>UV</name>
              <description>under voltage signal debounce enable. if set to '1, debounces the under voltage signal before going to under voltage interrupt generation else the signal bypass the debouncer</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OV</name>
              <description>over voltage signal debounce enable. if set to '1, debounces the over voltage signal before going to over voltage interrupt generation else the signal bypass the debouncer</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UVSTRB0SEL</name>
              <description>Low frequency strobing select for debouncing. Enables strobing 0 with the Low frequency clock(16K) instead of just clocking with High frequency Clock(16M). Default is set to 1 for debouncing of UV.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UVSTRB1SEL</name>
              <description>Low frequency strobing select for debouncing. Enables strobing 1 with the Low frequency clock(16K) instead of just clocking with High frequency Clock(16M). Default is set to 0 for quick acknowledgement of UV event.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OVSTRB0SEL</name>
              <description>Low frequency strobing select for debouncing. Enables strobing 0 with the Low frequency clock(16K) instead of just clocking with High frequency Clock(16M). Default is set to 1 for debouncing of OV.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OVSTRB1SEL</name>
              <description>Low frequency strobing select for debouncing. Enables strobing 1 with the Low frequency clock(16K) instead of just clocking with High frequency Clock(16M). Default is set to 0 for quick acknowledgement of OV event.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>VBATDBNCTHRES</name>
          <description>VBAT Monitor Threshold Register</description>
          <addressOffset>0x000000018</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>UVTHRES1</name>
              <description>Under Voltage debouncing threshold for 0to1 Transition. Sets the threshold for debouncing the under voltage event going from 0 to 1. It will require the uv event to stay high for the (UVTHRES1+1) number of LF/HF clocks to transit from a 0 to 1.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OVTHRES1</name>
              <description>Over Voltage debouncing threshold for 0to1 Transition. Sets the threshold for debouncing the over voltage event going from 0 to 1. It will require the ov event to stay high for the (OVTHRES1+1) number of LF/HF clocks to transit from a 0 to 1.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UVTHRES0</name>
              <description>Under Voltage debouncing threshold for 1to0 Transition. Sets the threshold for debouncing the under voltage event going from 1 to 0. It will require the uv event to stay high for the (UVTHRES0+1) number of LF/HF clocks to transit from a 1 to 0.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OVTHRES0</name>
              <description>Over Voltage debouncing threshold for 1to0 Transition. Sets the threshold for debouncing the over voltage event going from 1 to 0. It will require the ov event to stay high for the (OVTHRES0+1) number of LF/HF clocks to transit from a 1 to 0.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMUIRQ</name>
          <description>Voltage Monitor interrupts</description>
          <addressOffset>0x00000001C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>UV_ENABLE</name>
              <description>under voltage interrupt enable.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OV_ENABLE</name>
              <description>over voltage interrupt enable.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UV_CLEAR</name>
              <description>under voltage interrupt clear.
Autoclear: includes a synchronous reset signal which clears the register on the cycle following write.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>OV_CLEAR</name>
              <description>over voltage interrupt clear.
Autoclear: includes a synchronous reset signal which clears the register on the cycle following write.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>UV_STATUS</name>
              <description>under voltage interrupt status.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>OV_STATUS</name>
              <description>over voltage interrupt status.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>UV_ACTIVE</name>
              <description>under voltage interrupt active.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>OV_ACTIVE</name>
              <description>over voltage interrupt active.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>EVTHOLD</name>
      <version>B0</version>
      <description>Event Hold Control</description>
      <groupName>EVTHOLD</groupName>
      <prependToName>EVTHOLD_</prependToName>
      <baseAddress>0x50000060</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x0020</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>HOLD</name>
          <description>Hold. Set to prevent serialisation of new non-wakeup events in prepartion for hibernate mode. At the point of becoming set, a request to send the lullaby interrupt is automatically generated. The lullaby handler can then safely assert the PMUA-&gt;CTRL.HIBERNATE bit in order to put the device into hibernate mode.</description>
          <addressOffset>0x00000000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>HOLD</name>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>BTE</name>
      <version>B0</version>
      <description>Block Transfer Engine registers</description>
      <groupName>BTE</groupName>
      <prependToName>BTE_</prependToName>
      <baseAddress>0x50000080</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x0080</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>BTE_CTRL</name>
          <description>BTE Control Register</description>
          <addressOffset>0x00000000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>BXADD</name>
              <description>Address of the ASIC die (LSB). This is the lower 16 bits of the ASIC die address. The MSBs are 0x5001.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BXNUM</name>
              <description>Number of 32-bit words to transfer.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INC_ADDR</name>
              <description>if set then ASIC die address increments at the end of each transfer. Set to zero if the peripheral is a FIFO.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_DIR</name>
              <description>Transfer direction. If set then SRAM-&gt;ASIC otherwise ASIC-&gt;SRAM</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BLOCKING</name>
              <description>If set then the block transfer has priority over the MCU. If the MCU tries to use the bus, it will stall until the block transfer is complete. If not set, then the MCU waits only until the remainder of the current word completes and then waits until the bus is idle again before continuing.</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>START</name>
              <description>An operation is initiated when this bit is set. The bit auto-clears when the block is complete.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>BTE_SRAM_ADDR</name>
          <description>BTE SRAM Address Register</description>
          <addressOffset>0x00000004</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>BXSRAMADDR</name>
              <description>Address of the SRAM (LSB). This is the lower 16 bits of the SRAM address. The MSBs are 0x2000.
</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>WICA</name>
      <version>B0</version>
      <description>WakeUp Interrupt Controller</description>
      <groupName>WICA</groupName>
      <prependToName>WICA_</prependToName>
      <baseAddress>0x50010100</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x0100</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTRL</name>
          <description>Wakeup Control Registe</description>
          <addressOffset>0x00000000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>LINS_ENA</name>
              <description>LIN Slave Wakeup Enable. it enables the detect of a wakeup signal on the LIN_IN bus</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LINS_WICA_SEL</name>
              <description>LIN Slave Wakeup Source Select at Deepsleep mode.
'1' select the source from LIN Slave Control.
'0' select the source from pmu_pre5v(Default)</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TIMER_ENA</name>
              <description>Wakeup Timer Enable. it enables the wakeup timer</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TIMER_TAPSEL</name>
              <description>WakeUp Timer Tap Select. Wakeup Time = 2^(WUT_TAPSEL) x Tlfclk(62.5us)</description>
              <bitOffset>5</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LINS_IRQENA</name>
              <description>LIN Slave Wakeup Interrupt Enable. if set, wulin_irq is asserted if a wakeup signal is detected on the LIN_IN bus</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TIMER_IRQENA</name>
              <description>Timer Wakeup Interrupt Enable. if set, wutimer_irq is asserted if wakeup timer matches the tapsel</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LINS_IRQCLR</name>
              <description>clear the wulin_irq. writting a '1 to this register will clear the wulins_irq</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>TIMER_IRQCLR</name>
              <description>clear the wutimer_irq. writting a '1 to this register will clear the wutimer_irq</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS</name>
          <description>Wakeup Status Register</description>
          <addressOffset>0x00000004</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>LINS</name>
              <description>LIN Slave Wakeup Status. This gets set if a wakeup signal is detected on the LIN_IN bus when LINS SLEEP bit is set. CLRIRQ clears this Register</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TIMER</name>
              <description>Wakeup Timer Status. This gets set if a wakeup timer is enabled and the count matches the tapsel setting during hibernate, CLRIRQ clears this Register</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TIMERCNT</name>
              <description>Wakeup Timer Counter Value. Counter Value of the Wakeup Timer</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>WDTA</name>
      <version>B0</version>
      <description>Watchdog Timer Registers</description>
      <groupName>WDTA</groupName>
      <prependToName>WDTA_</prependToName>
      <baseAddress>0x50010300</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x0100</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTRL</name>
          <description>Control</description>
          <addressOffset>0x00000000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>UPDATE</name>
              <description>Window Mode Enable. Set to update Analog-Watchdog Configurations.
NOTE: DO NOT change the CTRL register when it is high, which indicates there is an update in progress, It gets cleared by the core when the current update is done</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>dual</access>
            </field>
            <field>
              <name>RUNNING</name>
              <description>Running status. A flag that indicates when the watchdog timer is enabled.
0x0: Watchdog timer is stopped and cleared
0x1: Watchdog timer is running</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TIMEOUTSEL</name>
              <description>Timeout select. Defines the watchdog timeout period (the time between a clear operation and the next timeout).
0x0: 2^10 * 62.5us ~= 128 ms
0x1: 2^11 * 62.5us ~= 256 ms
0x2: 2^12 * 62.5us ~= 512 ms
0x3: 2^13 * 62.5us ~= 1.0 s
0x4: 2^14 * 62.5us ~= 2.0 s
0x5: 2^15 * 62.5us ~= 4.0 s
0x6: 2^16 * 62.5us ~= 8.0 s
0x7: 2^17 * 62.5us ~= 16.0 s</description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WINOPENENA</name>
              <description>Window Mode Enable. Enables Window Mode.
1'b1: Enable the Window mode of Watchdog, if the WDT is cleared before the time window opens, the WDT will issue a system reset.
1'b0: Disable the Window mode of Watchdog.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WINOPENSEL</name>
              <description>Window Mode open select. Defines the watchdog window open time (the time between the watchdog start and the window open).
0x0: 1/2 * WDT timeout
0x1: 1/4 * WDT timeout
0x2: 1/8 * WDT timeout
0x3: 1/16* WDT timeout</description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WINOPENFLAG</name>
              <description>Window open flag. A flag that indicates when the watchdog window is open. It only can be cleared by Reg CLEAR!
0x0: Window is Closed
0x1: Window is Open</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STOP</name>
          <description>Stop</description>
          <addressOffset>0x00000004</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>STOP</name>
              <description>Stop. Write the *stop* code (0xc3) to this register to reset the timer and disable the watchdog (e.g. during debug). If any other value is written to this register the watchdog will be enabled.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>STOP_LOCK</name>
              <description>Set Only bit. Set this bit to lock STOP bits.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLEAR</name>
          <description>Clear</description>
          <addressOffset>0x00000008</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>CLEAR</name>
              <description>Clear. Write the value 0x3c574ad6 (as a single word access) to reset the watchdog timer. Periodically performing this action is the expected method of preventing the watchdog from timing out (and resetting the MCU).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CNTVAL</name>
          <description>Counter value</description>
          <addressOffset>0x0000000C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>CLEAR</name>
              <description>Counter value. The instantaneous value of watchdog timeout counter                    </description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INT</name>
          <description>WDTA Interrupts</description>
          <addressOffset>0x00000010</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>WDTA_ENABLE</name>
              <description>WDTA timeout Interrupt Enable.                  </description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WINOPEN_ENABLE</name>
              <description>Window Open Interrupt Enable.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>WDTA_CLEAR</name>
              <description>WDTA timeout Interrupt Clear.
Autoclear: includes a synchronous reset signal which clears the register on the cycle following write.                </description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>WINOPEN_CLEAR</name>
              <description>Window Open Interrupt Clear.
Autoclear: includes a synchronous reset signal which clears the register on the cycle following write.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>WDTA_STATUS</name>
              <description>WDTA timeout Status. Set by WDTA timeout</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>WINOPEN_STATUS</name>
              <description>Window Open Status. Set by WDTA timeout                 </description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>WDTA_ACTIVE</name>
              <description>WDTA timeout Interrupt. Set by WDTA timeout</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>WINOPEN_ACTIVE</name>
              <description>Window Open Interrupt. Set by WDTA timeout</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PWM</name>
      <version>B0</version>
      <description>Control (and status) registers for the pulse width modulation waveform generator.</description>
      <groupName>PWM</groupName>
      <prependToName>PWM_</prependToName>
      <baseAddress>0x50010600</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x0100</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>BASE</name>
          <description>Base functions</description>
          <addressOffset>0x00000000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>PRESCALESEL</name>
              <description>Prescaler select. Defines the ratio between the system clock and the clock used for the waveform generator.
0x0: Divide by 1
0x1: Divide by 2
0x2: Divide by 4
0x3: Divide by 8
0x4: Divide by 16
0x5: Divide by 64
0x6: Divide by 256
0x7: Divide by 1024</description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PERIOD</name>
              <description>Period. Specifies the period of the output waveform in terms of a number of prescaler output cycles.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWMCNT</name>
          <description>PWM Count Value</description>
          <addressOffset>0x00000004</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>PWMCNT</name>
              <description>PWM counter value to give a sense about the current period</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>dual</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ENAREQ</name>
          <description>Enable request</description>
          <addressOffset>0x00000008</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>ENAREQ</name>
              <description>Set to enable the waveform generator.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ENAREQALL</name>
              <description>Write 1 to enable all ENA_REQ bits; Write 0 has no effects.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CLRREQALL</name>
              <description>Write 1 to clear all ENA_REQ bits; Write 0 has no effects.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>FORCEINACTIVE</name>
              <description>Set to force PWM signals return to initial value immediately.</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ENASTS</name>
          <description>Enable status</description>
          <addressOffset>0x0000000C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>ENASTS</name>
              <description>Status of enable in the waveform generator.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INIT</name>
          <description>Intial State of Outputs</description>
          <addressOffset>0x00000010</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>INIT</name>
              <description>Set to initialise the output waveform.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INV</name>
          <description>Invert</description>
          <addressOffset>0x00000014</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>INVERT</name>
              <description>Set to initialise the output waveform.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UPDATE</name>
          <description>Update</description>
          <addressOffset>0x00000018</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>UPDATE</name>
              <description>Set to trigger consumption of new PULSE parameters (invert,prescale_sel,period,pulse start &amp; stop). The flag is automatically cleared by the hardware when the settings are consumed, so reading a high value indicates that an update is still pending.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>dual</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PULSE0</name>
          <description>PWM0 pulse setup</description>
          <addressOffset>0x0000001C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>PFALL0</name>
              <description>Pulse Fall. Specifies the pulse fall of the output waveform in terms of a number of prescaler output cycles. However, if INVERT is set it determines the pulse rise timing.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRISE0</name>
              <description>Pulse Rise. Specifies the pulse rise of the output waveform in terms of a number of prescaler output cycles. However, if INVERT is set it determines the pulse fall timing.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PULSE1</name>
          <description>PWM1 pulse setup</description>
          <addressOffset>0x00000020</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>PFALL1</name>
              <description>Pulse Fall. Specifies the pulse fall of the output waveform in terms of a number of prescaler output cycles. However, if INVERT is set it determines the pulse rise timing.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRISE1</name>
              <description>Pulse Rise. Specifies the pulse rise of the output waveform in terms of a number of prescaler output cycles. However, if INVERT is set it determines the pulse fall timing.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PULSE2</name>
          <description>PWM2 pulse setup</description>
          <addressOffset>0x00000024</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>PFALL2</name>
              <description>Pulse Fall. Specifies the pulse fall of the output waveform in terms of a number of prescaler output cycles. However, if INVERT is set it determines the pulse rise timing.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRISE2</name>
              <description>Pulse Rise. Specifies the pulse rise of the output waveform in terms of a number of prescaler output cycles. However, if INVERT is set it determines the pulse fall timing.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTPOSEDGENA</name>
          <description>PWM posedge interrupt enable</description>
          <addressOffset>0x00000028</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>INTPOSEDGENA</name>
              <description>Interrupt enable. bit[2:0]: posedge interrupt enable.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTNEGEDGENA</name>
          <description>PWM negedge interrupt enable</description>
          <addressOffset>0x0000002C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>INTNEGEDGENA</name>
              <description>Interrupt enable. bit[2:0]: negedge interrupt enable.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTPOSEDGCLR</name>
          <description>PWM posedge interrupt control</description>
          <addressOffset>0x00000030</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>INTPOSEDGCLR</name>
              <description>Interrupt clear. bit[2:0] : posedge interrupt clear.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTNEGEDGCLR</name>
          <description>PWM negedge interrupt control</description>
          <addressOffset>0x00000034</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>INTNEGEDGCLR</name>
              <description>Interrupt clear. bit[2:0] : negedge interrupt clear.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTPOSEDGSTS</name>
          <description>PWM posedge interrupt status</description>
          <addressOffset>0x00000038</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>INTPOSEDGSTS</name>
              <description>Interrupt status. bit[2:0] : posedge interrupt status.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTNEGEDGSTS</name>
          <description>PWM negedge interrupt status</description>
          <addressOffset>0x0000003C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>INTNEGEDGSTS</name>
              <description>Interrupt status. bit[2:0] : negedge interrupt status.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTPOSEDGIRQ</name>
          <description>PWM posedge interrupt active</description>
          <addressOffset>0x00000040</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>INTPOSEDGIRQ</name>
              <description>Interrupt active. bit[2:0] : posedge interrupt active.
</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTNEGEDGIRQ</name>
          <description>PWM negedge interrupt active</description>
          <addressOffset>0x00000044</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>INTNEGEDGIRQ</name>
              <description>Interrupt active. bit[2:0] : negedge interrupt active.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTPWM</name>
          <description>PWM interrupt control</description>
          <addressOffset>0x00000048</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>PERIOD_ENABLE</name>
              <description>Period Interrupt enable.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UPD_ENABLE</name>
              <description>Updated Interrupt enable.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PERIOD_CLEAR</name>
              <description>Period Interrupt clear.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>UPD</name>
              <description>Updated Interrupt clear.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>PERIOD_STATUS</name>
              <description>Period Interrupt status.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>UPD_STATUS</name>
              <description>Updated Interrupt status.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PERIOD_ACTIVE</name>
              <description>Period Interrupt active.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>UPD_ACTIVE</name>
              <description>Updated Interrupt active.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>LINS</name>
      <version>B0</version>
      <description>LIN slave interface registers</description>
      <groupName>LINS</groupName>
      <prependToName>LINS_</prependToName>
      <baseAddress>0x50010700</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x0100</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>DATABYTE1</name>
          <description>Data Byte 1</description>
          <addressOffset>0x00000000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>DATABUF1</name>
              <description>Data Buffer 1. 1st byte of the 8-byte Data Buffer. Only writable when the transaction is idle.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DATABUF2SHADOW</name>
              <description>Data Buffer 2 Shadow. Shadow register of 2nd byte of the 8-byte Data Buffer. Only writable when the transaction is idle.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>dual</access>
            </field>
            <field>
              <name>DATABUF3SHADOW</name>
              <description>Data Buffer 2 Shadow. Shadow register of 3rd byte of the 8-byte Data Buffer. Only writable when the transaction is idle.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>dual</access>
            </field>
            <field>
              <name>DATABUF4SHADOW</name>
              <description>Data Buffer 2 Shadow. Shadow register of 4th byte of the 8-byte Data Buffer. Only writable when the transaction is idle.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>dual</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DATABYTE2</name>
          <description>Data Byte 2</description>
          <addressOffset>0x00000004</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>DATABUF2</name>
              <description>Data Buffer 2. 2nd byte of the 8-byte Data Buffer. Only writable when the transaction is idle.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DATABYTE3</name>
          <description>Data Byte 3</description>
          <addressOffset>0x00000008</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>DATABUF3</name>
              <description>Data Buffer 3. 3rd byte of the 8-byte Data Buffer. Only writable when the transaction is idle.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DATABYTE4</name>
          <description>Data Byte 4</description>
          <addressOffset>0x0000000C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>DATABUF4</name>
              <description>Data Buffer 4. 4th byte of the 8-byte Data Buffer. Only writable when the transaction is idle.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DATABYTE5</name>
          <description>Data Byte 5</description>
          <addressOffset>0x00000010</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>DATABUF5</name>
              <description>Data Buffer 5. 5th byte of the 8-byte Data Buffer. Only writable when the transaction is idle.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DATABUF6SHADOW</name>
              <description>Data Buffer 6 Shadow. Shadow register of 6th byte of the 8-byte Data Buffer. Only writable when the transaction is idle.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>8</bitWidth>
              <access>dual</access>
            </field>
            <field>
              <name>DATABUF7SHADOW</name>
              <description>Data Buffer 7 Shadow. Shadow register of 7th byte of the 8-byte Data Buffer. Only writable when the transaction is idle.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>dual</access>
            </field>
            <field>
              <name>DATABUF8SHADOW</name>
              <description>Data Buffer 8 Shadow. Shadow register of 8th byte of the 8-byte Data Buffer. Only writable when the transaction is idle.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>8</bitWidth>
              <access>dual</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DATABYTE6</name>
          <description>Data Byte 6</description>
          <addressOffset>0x00000014</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>DATABUF6</name>
              <description>Data Buffer 6. 6th byte of the 8-byte Data Buffer. Only writable when the transaction is idle.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DATABYTE7</name>
          <description>Data Byte 7</description>
          <addressOffset>0x00000018</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>DATABUF7</name>
              <description>Data Buffer 7. 7th byte of the 8-byte Data Buffer. Only writable when the transaction is idle.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DATABYTE8</name>
          <description>Data Byte 8</description>
          <addressOffset>0x0000001C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>DATABUF8</name>
              <description>Data Buffer 8. 8th byte of the 8-byte Data Buffer. Only writable when the transaction is idle.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CTRL</name>
          <description>Control Register</description>
          <addressOffset>0x00000020</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>WAKEUPREQ</name>
              <description>WakeUp Request. The bit has to be set by the host controller to terminate the Sleep Mode of the LIN bus by sending a Wakeup signal. The bit will be reset by the LIN core.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RSTERR</name>
              <description>Reset Error. The host controller has to set this bit to reset the error bits in status register and error register. A read access to this bit delivers always the value 0.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>RSTINT</name>
              <description>Reset interrupt. The host controller has to set this bit to reset the STATUS.INTR register and the interrupt request output of the LIN core. A read access to this bit delivers always the value 0.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>DATAACK</name>
              <description>Data Acknowledgement. The bit has to be set by the host controller of a LIN slave after handling a data request interrupt (compare STATUS.DATA_REQ register). The bit will be reset by the LIN core.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TRANSMIT</name>
              <description>Transmit Operation. The bit determines whether the current frame is a transmit frame or a receive frame for the LIN node. It has to be set by the host controller.
0x0: receive operation
0x1: transmit operation</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SLEEP</name>
              <description>Sleep Request. The bit is used by the LIN core to determine whether the LIN bus is in Sleep Mode or not. The host controller has to set the bit after sending or receiving a Sleep Mode frame. If DIS_AUTOSLEEP = 0, the bit will be set automatically by the LIN core if a bus idle timeout is detected. The host controller has to clear the bit after a wakeup signal is detected.
NOTE: When the chip uses the LINs wakeup logic in pre5v domain(PMU_SFRS-&gt;CTRL.PD1V5_ENA_HIBERNATE=0x0), the write operation of this register takes effect by IOCTRLA_SFRS-&gt;LIN.UPDATE</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>STOP</name>
              <description>Stop Register. The host controller of the LIN slave has set this register if it handles a data request interrupt and can not make use of the frame content with the received identifier(e.g. extended identifiers). For that case the LIN slave stops the processing of the LIN communication until the next SYNC BREAK is detected. A read access to this bit delivers always the value 0
Autoclear: includes a synchronous reset signal which clears the register on the cycle following write.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS</name>
          <description>Status</description>
          <addressOffset>0x00000024</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>COMPLETE</name>
              <description>Complete. The LIN core will set the bit after a transmission has been successfully finished and it will reset it at the start of a transmission</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>WAKEUP</name>
              <description>WakeUp. The bit is set when the LIN core is transmitting a Wakeup signal.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ERROR</name>
              <description>Lin Error. The LIN core sets the bit if an error has been detected (compare error register). The bit has to be reset by the host controller by setting the bit CTRL.RST_ERR register</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>INTR</name>
              <description>Interupt Request. The LIN core sets the bit when it requests an interrupt to the host controller. It has the same value as the interrupt output INTR. The bit has to be reset by the host controller by setting the bit CTRL.RST_INT register</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>DATAREQ</name>
              <description>Data Request. The LIN core slave sets the bit after receiving the Identifier and requests an interrupt to the host controller. The host controller has to decode the Identifier to decide whether the current frame is a transmit or a receive operation. It has to adjust CTRL.TRANSMIT register and to load the data length. For transmit operations it has to load the data buffer too. After that the host controller has to set CTRL.DATA_ACK register</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ABORTED</name>
              <description>Aborted. The bit is set if the processing of the current frame has been stopped by setting CTRL.STOP register. The bit is cleared by the LIN core after receiving a correct SYNC BREAK / SYNC FIELD sequence</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>BUSIDLETIMEOUT</name>
              <description>BUS Idle Timeout. This bit is set by the LIN core if LIN is in hardware mode and no bus activity is detected for 4s~10s. In addition, an interrupt request to the host controller is generated in that case. After that, It is assumed that the LIN bus is in sleep mode and CTRL.SLEEP register will be set by the LIN core. The bit has to be reset by the host controller by setting the bit CTRL.RST_INT register.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ACTIVE</name>
              <description>Lin Bus Active. The bit indicates whether the LIN bus is active or not. Note: For the LIN slave, this bit is set after the detection of a correct SYNC BREAK / SYNC FIELD sequence and it is reset at the end of the transmission or if the processing of the current frame is stopped by the host controller
0x0: no Lin bus activity
0x1: transmission on the LIN bus is active</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ERROR</name>
          <description>Error Register</description>
          <addressOffset>0x00000028</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>BITERR</name>
              <description>Bit Error in Byte field. Bit Error in Byte field, i.e., invalid stop bit.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>CHK</name>
              <description>Checksum Error. Checksum Error</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>TIMEOUT</name>
              <description>Timeout Error. There are several reason that can cause a timeout error: The master detects a timeout error if it is expecting data from the bus but no slave does respond. If the slave responds to late and the frame is not finished within the maximum frame length TFRAME_MAX a timeout error will be detected too. The slave detects a timeout error if it is requesting a data acknowledge to the host controller (for selecting receive or transmit, data length and loading data), and the host controller does not set CTRL.DATA_ACK or CTRL.STOP register until the end of the reception of the first byte after the identifier. The slave detects a timeout error if it has transmitted a wakeup signal and it detects no sync field (from the master) within 150 ms. Note: The slave does not perform an exact check of the frame length TFRAME_MAX but a timeout is detected after 200 bit times, if the slave is in receive mode and there are missing data fields or a missing ID field from the master.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PARITY</name>
              <description>Parity Error. Identifier parity error</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>BITMON</name>
              <description>Bit Monitor Error. The Bit value monitored on the bus is different from the sent bit value, bit monitor error will trigger an interrupt</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>SBITERR</name>
              <description>Start Bit Error in Byte field. Start Bit Error in Byte field, i.e., invalid start bit.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>FRAMEERR</name>
              <description>Byte Field Framing Error. This bit is set by the LIN core slave if a transmission is aborted after the beginning of the data field due to a timeout or an incomplete frame</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>BITMONSTOP</name>
              <description>Bit Monitor Error occurred in Stop Bit. The Bit value monitored on the bus is different from the sent bit value and the error occurrs on the stop bit. In SAE2602, the error belongs to framing error.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>BITMONDATA</name>
              <description>Bit Monitor Error occurred in Start or Data Bits. The Bit value monitored on the bus is different from the sent bit value and the error occurrs on the start or data bits.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DL</name>
          <description>DATA Length Register</description>
          <addressOffset>0x0000002C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>LENGTH</name>
              <description>Data Length. The host controller has to define the length of the data field of the current LIN frame by adjusting the data length register. If the data length is loaded with the value 1111b the length of the data field is decoded from Bit 5 and 4 of the identifier register id according to the Table below (e.g. compatibility to LIN specification 1.1). Otherwise the amount of data bytes can be written directly to the data length register (supported values are 0..8).

ID (Bit 5)	ID (Bit 4)	Number of Bytes in the data field
0	          0	               2
0	          1	               2
1	          0	               4
1	          1	               8</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DISAUTOSLEEP</name>
              <description>Disable Auto Sleep. Set to Disable auto sleep.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DISBITMON</name>
              <description>Disable Bit Monitor. Set to disable the bit monitor during transmission. The bit must be set in case that RXD/TXD are separated.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ENHCHK</name>
              <description>Enhancement Check. The host controller has to set the checksum type used in the current frame by adjusting this register.
0x0: for classic checksum
0x1: for enhanced checksum</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>BTDIV07</name>
          <description>Bit time Divider Register</description>
          <addressOffset>0x00000030</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>BTDIV07</name>
              <description>Bt Div LSBs. Bit time divider [7:0]</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>BITTIME</name>
          <description>Control Settings</description>
          <addressOffset>0x00000034</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>BTDIV8</name>
              <description>Bt Div Most Significant bit. Bit time divider [8]</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRESCL</name>
              <description>Prescaler Register. Prescaler Setting</description>
              <bitOffset>6</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ID</name>
          <description>ID Register</description>
          <addressOffset>0x00000038</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>ID</name>
              <description>ID. ID register</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>BUSTIME</name>
          <description>Lin Bus Timing Register                                                                                                                                  Lin Bus Timing Register. Table 2-9 Control of time settings for wup_repeat_time and bus_inactivity_time

Bit 3	Bit 2	Bit 1	Bit 0	Time
0	0	0	0	Reset value
0	0			4 s (bus_inactivity_time)
0	1			6 s (bus_inactivity_time)
1	0			8 s (bus_inactivity_time)
1	1			10 s (bus_inactivity_time)
                0	0	180 ms (wup_repeat_time)
                0	1	200 ms (wup_repeat_time)
                1	0	220 ms (wup_repeat_time)
                1	1	240 ms (wup_repeat_time)</description>
          <addressOffset>0x0000003C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>WUPREPEAT</name>
              <description>wakeup repeat time.                                                                                                                                     </description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BUSINACTIVE</name>
              <description>Bus Inactivity Time. NOTE: When the chip uses the LINs bus idle detection in pre5v domain(PMU_SFRS-&gt;CTRL.PD1V5_ENA_HIBERNATE=0x0), the write operation of this register takes effect by IOCTRLA_SFRS-&gt;LIN.UPDATE</description>
              <bitOffset>2</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BUSDOMINANTRELEASEWUPENA</name>
              <description>Bus Dominant Release Wakeup Enable. NOTE: When the chip uses the LINs bus idle detection in pre5v domain(PMU_SFRS-&gt;CTRL.PD1V5_ENA_HIBERNATE=0x0), the write operation of this register takes effect by IOCTRLA_SFRS-&gt;LIN.UPDATE	</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUSEXT</name>
          <description>Extended Status</description>
          <addressOffset>0x00000040</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>COMPLETETX</name>
              <description>Complete TX. The LIN core will set the bit after a TX transmission has been successfully finished and it will reset it at the start of a transmission.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>BUSIDLETIMEOUTDOMINANT</name>
              <description>Dominant Bus Idle Timeout. The bit is set by the lin core if LIN is in hardware mode &amp; the bus is stuck at dominant inactivity state for 4s~10s. The bit has to be reset by the host controller by setting the bit CTRL.RST_INT register.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>BUSIDLEMONITOR</name>
              <description>Bus Idle Monitor Status. If LIN is in hardware mode, BIT[0] is set by the lin core if the bus has no activity for 4s~10s and BIT[1] is set by the lin core if LIN is stuck at dominant inactivity state for 4s~10s. Any bus transition will clear these two bits. LIN Slave's pullup will be disabled &amp; LIN Master's pullup will be reduced to 30K when BIT[1] is set.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WUPDETECTTHRES</name>
          <description>Wakeup Detection Threshold</description>
          <addressOffset>0x00000044</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>WUPDETECTTHRES</name>
              <description>Wakeup Detection Threshold. Threshold setting(LF_CLK_PREDIV clock cycls) of lin wakeup signal. For instace, if target threshold is 150us@LF_CLK_PREDIV=250KHz, WUP_DETECT_THRES = 150/(1000/250)-1.
NOTE: When the chip uses the LINs wakeup logic in pre5v domain(PMU_SFRS-&gt;CTRL.PD1V5_ENA_HIBERNATE=0x0), the write operation of this register takes effect by IOCTRLA_SFRS-&gt;LIN.UPDATE</description>
              <bitOffset>0</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CONF</name>
          <description>Extended Configuration Register for compatibility issue</description>
          <addressOffset>0x00000048</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>INTERBYTECNT</name>
              <description>Inter-Byte Space Bit Count. Bit count of inter-byte space. &gt;= 1bit inter-byte space is required by some legacy LIN devices. Only writable when the transaction is idle.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>BITMONMODE</name>
              <description>BIT Monitor Mode. Control the exit timing when bit monitor error occured. Only writable when the transaction is idle.
0x0: Default. The transmission finished immediately if bit_mon is detected.
0x1: Even bit_mon is detected, the transmission will not be finished until the byte transfer is completed.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PWM_AUX</name>
      <version>B0</version>
      <description>Control (and status) registers for the pulse width modulation waveform generator.</description>
      <groupName>PWM_AUX</groupName>
      <prependToName>PWM_AUX_</prependToName>
      <baseAddress>0x50010900</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x0100</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>BASE0</name>
          <description>Base 0 functions</description>
          <addressOffset>0x00000000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>PRESCALESEL0</name>
              <description>Prescaler select. Defines the ratio between the system clock and the clock used for the waveform generator.
0x0: Divide by 1
0x1: Divide by 2
0x2: Divide by 4
0x3: Divide by 8
0x4: Divide by 16
0x5: Divide by 64
0x6: Divide by 256
0x7: Divide by 1024</description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PERIOD0</name>
              <description>Period. Specifies the period of the output waveform in terms of a number of prescaler output cycles.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWMCNT0</name>
          <description>PWM Count Value</description>
          <addressOffset>0x00000004</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>PWMCNT0</name>
              <description>PWM counter value to give a sense about the current period</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>BASE1</name>
          <description>Base 1 functions</description>
          <addressOffset>0x00000008</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>PRESCALESEL1</name>
              <description>Prescaler select. Defines the ratio between the system clock and the clock used for the waveform generator.
0x0: Divide by 1
0x1: Divide by 2
0x2: Divide by 4
0x3: Divide by 8
0x4: Divide by 16
0x5: Divide by 64
0x6: Divide by 256
0x7: Divide by 1024</description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PERIOD1</name>
              <description>Period. Specifies the period of the output waveform in terms of a number of prescaler output cycles.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWMCNT1</name>
          <description>PWM Count Value</description>
          <addressOffset>0x0000000C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>PWMCNT1</name>
              <description>PWM counter value to give a sense about the current period</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>BASESEL</name>
          <description>Base Timer Select for individual Channels</description>
          <addressOffset>0x00000010</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>BASE_SEL</name>
              <description>Base Selects:
bit0:1=PWM0 Select BASE1, 0=PWM0 Select BASE0.
bit1:1=PWM1 Select BASE1, 0=PWM1 Select BASE0.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ENAREQ</name>
          <description>Enable request</description>
          <addressOffset>0x00000014</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>ENAREQ</name>
              <description>Set to enable the pwm channel.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ENAREQALL</name>
              <description>Write 1 to enable all ENA_REQ bits; Write 0 has no effects.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CLRREQALL</name>
              <description>Write 1 to clear all ENA_REQ bits; Write 0 has no effects.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>FORCEINACTIVE</name>
              <description>Set to force PWM signals return to initial value immediately.</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ENASTS</name>
          <description>Intial State of Outputs</description>
          <addressOffset>0x00000018</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>ENASTS</name>
              <description>Status of enable in the pwm channel.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INIT</name>
          <description>Intial State of Outputs</description>
          <addressOffset>0x0000001C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>INIT</name>
              <description>Set to initialise the output waveform.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INV</name>
          <description>Invert</description>
          <addressOffset>0x00000020</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>INVERT</name>
              <description>Set to invert the output waveform.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UPDATE</name>
          <description>Update</description>
          <addressOffset>0x00000024</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>UPDATE</name>
              <description>Set to trigger consumption of new PULSE parameters (invert,prescale_sel,period,pulse start &amp; stop). The flag is automatically cleared by the hardware when the settings are consumed, so reading a high value indicates that an update is still pending.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>dual</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PULSE0</name>
          <description>PWM0 pulse setup</description>
          <addressOffset>0x00000028</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>PFALL0</name>
              <description>Pulse Fall. Specifies the pulse fall of the output waveform in terms of a number of prescaler output cycles. However, if INVERT is set it determines the pulse rise timing.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRISE0</name>
              <description>Pulse Rise. Specifies the pulse rise of the output waveform in terms of a number of prescaler output cycles. However, if INVERT is set it determines the pulse fall timing.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PULSE1</name>
          <description>PWM1 pulse setup</description>
          <addressOffset>0x0000002C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>PFALL1</name>
              <description>Pulse Fall. Specifies the pulse fall of the output waveform in terms of a number of prescaler output cycles. However, if INVERT is set it determines the pulse rise timing.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRISE1</name>
              <description>Pulse Rise. Specifies the pulse rise of the output waveform in terms of a number of prescaler output cycles. However, if INVERT is set it determines the pulse fall timing.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PULSE2</name>
          <description>PWM2 pulse setup</description>
          <addressOffset>0x00000030</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>PFALL2</name>
              <description>Pulse Fall. Specifies the pulse fall of the output waveform in terms of a number of prescaler output cycles. However, if INVERT is set it determines the pulse rise timing.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRISE2</name>
              <description>Pulse Rise. Specifies the pulse rise of the output waveform in terms of a number of prescaler output cycles. However, if INVERT is set it determines the pulse fall timing.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PULSE3</name>
          <description>PWM3 pulse setup</description>
          <addressOffset>0x00000034</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>PFALL3</name>
              <description>Pulse Fall. Specifies the pulse fall of the output waveform in terms of a number of prescaler output cycles. However, if INVERT is set it determines the pulse rise timing.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRISE3</name>
              <description>Pulse Rise. Specifies the pulse rise of the output waveform in terms of a number of prescaler output cycles. However, if INVERT is set it determines the pulse fall timing.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTPOSEDGENA</name>
          <description>PWM posedge interrupt enable</description>
          <addressOffset>0x00000038</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>INTPOSEDGENA</name>
              <description>Interrupt enable. bit[3:0]: posedge interrupt enable.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTNEGEDGENA</name>
          <description>PWM negedge interrupt enable</description>
          <addressOffset>0x0000003C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>INTNEGEDGENA</name>
              <description>Interrupt enable. bit[3:0]: negedge interrupt enable.                                                                                                                                   </description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTPOSEDGCLR</name>
          <description>PWM posedge interrupt control</description>
          <addressOffset>0x00000040</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>INTPOSEDGCLR</name>
              <description>Interrupt clear. bit[3:0] : posedge interrupt clear.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTNEGEDGCLR</name>
          <description>PWM negedge interrupt control</description>
          <addressOffset>0x00000044</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>INTNEGEDGCLR</name>
              <description>Interrupt clear. bit[3:0] : negedge interrupt clear.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTPOSEDGSTS</name>
          <description>PWM posedge interrupt status</description>
          <addressOffset>0x00000048</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>INTPOSEDGSTS</name>
              <description>Interrupt status. bit[3:0] : posedge interrupt status.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTNEGEDGSTS</name>
          <description>PWM negedge interrupt status</description>
          <addressOffset>0x0000004C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>INTNEGEDGSTS</name>
              <description>Interrupt status. bit[3:0] : negedge interrupt status.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTPOSEDGIRQ</name>
          <description>PWM posedge interrupt active</description>
          <addressOffset>0x00000050</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>INTPOSEDGIRQ</name>
              <description>Interrupt active. bit[3:0] : posedge interrupt active.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTNEGEDGIRQ</name>
          <description>PWM negedge interrupt active</description>
          <addressOffset>0x00000054</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>INTNEGEDGIRQ</name>
              <description>Interrupt active. bit[3:0] : negedge interrupt active.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTPERIOD</name>
          <description>PWM Period interrupt control</description>
          <addressOffset>0x00000058</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>ENABLE</name>
              <description>Period Interrupt enable.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CLEAR</name>
              <description>Period Interrupt clear.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>STATUS</name>
              <description>Period Interrupt status.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ACTIVE</name>
              <description>Period Interrupt active.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTUPDATED</name>
          <description>PWM Updated interrupt control</description>
          <addressOffset>0x0000005C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>ENABLE</name>
              <description>Updated Interrupt enable.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CLEAR</name>
              <description>Updated Interrupt clear.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>STATUS</name>
              <description>Updated Interrupt status.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>ACTIVE</name>
              <description>Updated Interrupt active.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>SAR_CTRL</name>
      <version>B0</version>
      <description>SAR ADC Interface registers</description>
      <groupName>SAR_CTRL</groupName>
      <prependToName>SAR_CTRL_</prependToName>
      <baseAddress>0x50010D00</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x0100</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>DATA1</name>
          <description>Data Out of CH1,</description>
          <addressOffset>0x00000000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>DATA1</name>
              <description>The result of ADC conversion of CH1(in 2's-complement)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DATA2</name>
          <description>Data Out of CH2,</description>
          <addressOffset>0x00000004</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>DATA2</name>
              <description>The result of ADC conversion of CH2(in 2's-complement)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DATA3</name>
          <description>Data Out of CH3,</description>
          <addressOffset>0x00000008</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>DATA3</name>
              <description>The result of ADC conversion of CH3(in 2's-complement)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DATA4</name>
          <description>Data Out of CH4,</description>
          <addressOffset>0x0000000C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>DATA4</name>
              <description>The result of ADC conversion of CH4(in 2's-complement)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SARANACFG</name>
          <description>SAR Analog Configuration Register</description>
          <addressOffset>0x00000010</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>ADCVREFSEL</name>
              <description>adc vref select.
0x0: adc_vref = vbg when sar_ena_req=1
0x1: adc_vref = 2*vbg when sar_ena_req=1
0x2: adc_vref = VDD_3V3 when sar_ena_req=1
0x3: adc_vref = VDD_3V3 when sar_ena_req=1</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SARPREAMPEN</name>
              <description>adc pre-amp enable.
0:disable,
1:enable</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SARCFG</name>
          <description>SAR Configuration Register</description>
          <addressOffset>0x00000014</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>SAMPCYC</name>
              <description>Sample cycle. setting sampling time from 1 to 16 sar clock cycles.
0x0: 1 Cycle
0x1: 2 Cycle
0x2: 3 Cycle
0xf: 16 Cycle</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ROUND</name>
              <description>ADC round enable. Enable ADC round.
0x0: No round.
0x1: Negative code+1</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIGSEL</name>
              <description>SAR Converion Trigger Selects. Selects the trigger condition of SAR ADC. Don't change the bits during an ADC conversion sequence is ongoing.
0x1: Triggered through writing 1 to conversion bit.
0x2: Triggered by the PWM posedge.
0x4: Triggered by the PWM negedge.
0x8: Triggered by PWM period.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PWMSEL</name>
              <description>PWM Trigger Signal Selects. Selects the source PWM channel.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIGDLY</name>
              <description>trigger delay. setting trigger delay time from 0 to 15 sar clock cycles. For PN-detect, trigger delay MUST &gt;= 2us.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AFECTRL</name>
          <description>SAR AFE Control</description>
          <addressOffset>0x00000018</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>ADCSELVINVCMEXT</name>
              <description>Select External Inputs to ADC. choose ADC input common voltage. 0: choose internal vin_vcm, equals to (vinp+vinn)/2; 1: choose external vin_vcm, for PN detect.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SARAFEEN</name>
              <description>ADC AFE Enable. adc afe enable. If vinp, vinn and vin vcm all choose external, adc afe should be disabled: adc_adc_en=0, otherwise, adc afe must be enabled: adc_afe_en=1.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SARINPUTMODE</name>
              <description>ADC AFE Input Modes. Select ADC AFE Input Modes.
0x0: All external.
0x1: VINP buffered, VINN external.
0x2: VINN buffered, VINP external.
0x3: Both VINP &amp; VINN buffered.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SARINPUTGAIN</name>
              <description>choose ADC input gain.
0x0: 22/32
0x1: 31/32</description>
              <bitOffset>14</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SARCTRL</name>
          <description>SAR ADC Control</description>
          <addressOffset>0x0000001C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>SARENAREQ</name>
              <description>SAR ADC Enable. Set to enable the SAR analog &amp; digital part</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DIGRESET</name>
              <description>SAR Digital Part Reset. Resets SAR digital parts.
Autoclear: includes a synchronous reset signal which clears the register on the cycle following write.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CONVERT</name>
              <description>ADC START/STATUS Register. If SOFTWARE trigger source is selected, set to start a conversion, If SARBAUD trigger source is selected, set to activate the internal baud generator. The tick of the buad generator will trigger an ADC conversion. Read 1 indicates ADC conversion is active; Read 0 indicates ADC is in idle state.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>dual</access>
            </field>
            <field>
              <name>CONT</name>
              <description>Continuous Conversion Enable. If this bit has been set before an ADC conversion sequence trigged by CONVERT bit or PWM signals, the sequence will be treated as a sequential conversion, rather than a single conversion.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ADCCHCONF</name>
          <description>ADC Channel Configuration</description>
          <addressOffset>0x00000020</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>SEQCNT</name>
              <description>Channel Sequence count. Selects the sequence of channels to be converted

0x1: CH1 only
0x2: CH1-&gt;CH2
0x3: CH1-&gt;CH2-&gt;CH3
0x4: CH1-&gt;CH2-&gt;CH3-&gt;CH4</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH1SEL</name>
              <description>Channel1 Selection. Channel1 Selects.
0x1: adc_vinp=adc_refp , adc_vinn=adc_refp (all shot to adc_ref(2.4V) for adc channel offset K)
0x2: adc_vinp=adc_refp , adc_vinn=vref_gnd (for adc channel +gain error K)
0x3: adc_vinp=vref_gnd , adc_vinn=adc_refp (for adc channel -gain error K)
0x4: adc_vinp=TempSensor , adc_vinn=vref_gnd
0x5: adc_vinp=VDD_1V5 , adc_vinn=vref_gnd
0x6: adc_vinp=VDD_3V3 , adc_vinn=vref_gnd
0x7: adc_vinp=VDD_PRE5V (1/4) , adc_vinn=vref_gnd
0x8: adc_vinp=VBAT ACCURATE (gain selected by TEST_BATTERY_GAIN_CHOOSE), adc_vinn=vref_gnd
0x9: adc_vinp=LED0 , adc_vinn=vref_gnd
0xa: adc_vinp=LED1 , adc_vinn=vref_gnd
0xb: adc_vinp=LED2 , adc_vinn=vref_gnd
0xc: adc_vinp=GPIO1 , adc_vinn=vref_gnd
0xd: adc_vinp=GPIO2 , adc_vinn=vref_gnd
0xe: adc_vinp=GPIO3 , adc_vinn=vref_gnd
0xf: adc_vinp=GPIO4 , adc_vinn=vref_gnd
0x10: adc_vinp=VBAT , adc_vinn=LED0 (with gain selected by ioctrla.LED.GAIN_SEL)
0x11: adc_vinp=VBAT , adc_vinn=LED1 (with gain selected by ioctrla.LED.GAIN_SEL)
0x12: adc_vinp=VBAT , adc_vinn=LED2 (with gain selected by ioctrla.LED.GAIN_SEL)</description>
              <bitOffset>3</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH2SEL</name>
              <description>Channel2 Selection. Refer to Channel1 Selects.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH3SEL</name>
              <description>Channel3 Selection. Refer to Channel1 Selects.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>CH4SEL</name>
              <description>Channel4 Selection. Refer to Channel1 Selects.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>5</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TESTBATTERYGAINCHOOSE</name>
              <description>VBAT Gain Select.
0: gain=1/14, vbat max 30V/14=2.14v, under ADC vref=2.4v
1: gain=1/28, vbat max 30V/28=1.07v, under ADC vref=1.2v</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SARINT</name>
          <description>Update</description>
          <addressOffset>0x00000024</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>INT_CONV_DONE_ENA</name>
              <description>Convert Done Interrupt Enable.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>INT_CONV_DONE_CLR</name>
              <description>Convert Done Interrupt Clear.
Autoclear: includes a synchronous reset signal which clears the register on the cycle following write.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>CONV_DONE</name>
              <description>Convert Done. Set by the SAR when an conversion is done.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>INT_CONV_DONE</name>
              <description>Convert Done Interrupt. Set by the SAR when an convert done occurs</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SARCLKDIV</name>
          <description>SAR CLOCK DIVIDE</description>
          <addressOffset>0x00000028</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>SARCLKDIV</name>
              <description>SAR CLOCK DIVIDE.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>IOCTRLA</name>
      <version>B0</version>
      <description>I/O configuration and DFT pin control</description>
      <groupName>IOCTRLA</groupName>
      <prependToName>IOCTRLA_</prependToName>
      <baseAddress>0x50011000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x1000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>GPIO1</name>
          <description>GPIO Pin 1 Control</description>
          <addressOffset>0x00000000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>HWMODE</name>
              <description>hardware mode.
0x0: GPIO Mode. 'GPIO Barium' reads and writes data to the GPIO. Output Enable is controlled by GPIO Barium via the direction bit. Read Enable, Pull-Up, and Pull-Down are controlled by GPIO register in IOCTRLA.
0x1: PWM Mode. 'PWM Barium' writes data to the GPIO.
0x2: Testmux Mode. 'Digital Testmux' writes data to the GPIO. DEBUG Access must be enabled in the system control block to allow testmux outputs.
0x3: GPIO1_LINS_SEL=0 : LINS RXD; GPIO1_LINS_SEL=1 : Single wire mode, LINS RXD/LINS TXD, Open-drain output.
0x4: Monitor 1st Stage input of LINS RX Glitch filter.
0x5: Monitor 1st Stage output of LINS RX Glitch filter.
0x6: Monitor 2nd Stage output of LINS RX Glitch filter.
0x7: Monitor 3rd Stage output of LINS RX Glitch filter.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LINS_SEL</name>
              <description>LINS Connection Select.
0x0: LINS RXD External input Mode.
0x1: Single wire mode, LINS RXD/LINS TXD, Open-drain output.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PUENA</name>
              <description>pullup enable (active-low).
0x0: Enable 100K Ohm Pull Up
0x1: Disable 100K Ohm Pull Up</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PDENA</name>
              <description>pulldown enable.
0x0: Disable 100K Ohm Pull Down
0x1: Enable 100K Ohm Pull Down</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RDENA</name>
              <description>read enable.
0x0: Disable Read path on the GPIO
0x1: Enable Read path on the GPIO</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIO2_MUXSEL</name>
              <description>Selects debug signal to be output on gpio2.
Refer to GPIO1_MUXSEL for signal selection</description>
              <bitOffset>16</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>MUXSEL</name>
              <description>GPIO1_MUXSEL:Selects debug signal to be output on gpio1.
0x0: PMUA (Power Management Unit Asic) QACK
0x1: PMUA (Power Management Unit Asic) Wakeup signal
0x2: PMUA (Power Management Unit Asic) snowflake
0x3: LIN Slave Output of 1st Stage Glitch Filter
0x4: LIN Slave Output of 2nd Stage Glitch Filter
0x5: LIN Slave Output of 3rd Stage Glitch Filter
0x6: LIN Slave PHY Output Rxd
0x7: LIN Slave PHY Input Txd
0x8: CRGA (Clock Reset Generation Asic) (scan_test_mode | lf_rc_clk)
0x9: CRGA (Clock Reset Generation Asic) (scan_test_mode | hf_rc_clk)
0xa: CRGA (Clock Reset Generation Asic) (scan_test_mode | lf_rc_sts)
0xb: CRGA (Clock Reset Generation Asic) (scan_test_mode | hf_rc_sts)
0xc: CRGA (Clock Reset Generation Asic) (scan_test_mode | clk_sys_gated)
0xd: CRGA (Clock Reset Generation Asic) (a_por_n)
0xe: CRGA (Clock Reset Generation Asic) (bor_3v3_n)
0xf: CRGA (Clock Reset Generation Asic) (ovtemp_flag)
0x10: CRGA (Clock Reset Generation Asic) (bor_1v5_n)
0x11: CRGA (Clock Reset Generation Asic) (wdt_bark)
0x12: ADC controller clk adc_clk_in
0x22: LIN Slave Input of Core rxd
0x23: LIN Slave Output of Core txd
0x24: BOR CONTROL STATE MACHINE state[0]
0x25: BOR CONTROL STATE MACHINE state[1]
0x26: BOR CONTROL STATE MACHINE bor_bias_ena
0x27: BOR CONTROL STATE MACHINE bor_bias_ena_l
0x28: BOR CONTROL STATE MACHINE pmua_bor_bias_ena
0x29: BOR CONTROL STATE MACHINE hf_clk_allowed
0x2a: BOR CONTROL STATE MACHINE hf_active
0x2b: BOR CONTROL STATE MACHINE pmua_bor_arm_sync
0x2c: BATTERY VOLTAGE MONITOR vbat_low
0x2d: BATTERY VOLTAGE MONITOR vbat_high
0x2e: BATTERY VOLTAGE MONITOR vbat_low_flag
0x2f: BATTERY VOLTAGE MONITOR vbat_high_flag
0x30: BATTERY VOLTAGE MONITOR vbat_low_dbnc
0x31: BATTERY VOLTAGE MONITOR vbat_high_dbnc</description>
              <bitOffset>24</bitOffset>
              <bitWidth>6</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIO2</name>
          <description>GPIO Pin 2 Control</description>
          <addressOffset>0x00000004</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>HWMODE</name>
              <description>hardware mode.
0x0: GPIO Mode. 'GPIO Barium' reads and writes data to the GPIO. Output Enable is controlled by GPIO Barium via the direction bit. Read Enable, Pull-Up, and Pull-Down are controlled by GPIO register in IOCTRLA.
0x1: PWM Mode. 'PWM Barium' writes data to the GPIO.
0x2: LINS PHY TXD Drive Mode. GPIO input connects to LINS PHY TXD. DEBUG Access must be enabled in the system control block to drive LINS PHY TXD outputs.
0x3: LINS Core TXD Monitor.
0x4: Testmux Mode. 'Digital Testmux' writes data to the GPIO. DEBUG Access must be enabled in the system control block to allow testmux outputs.
0x5: Monitor 1st Stage output of LINS RX Glitch filter.
0x6: Monitor 2nd Stage output of LINS RX Glitch filter.
0x7: Monitor 3rd Stage output of LINS RX Glitch filter.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PUENA</name>
              <description>pullup enable (active-low).
0x0: Enable 100K Ohm Pull Up
0x1: Disable 100K Ohm Pull Up</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PDENA</name>
              <description>pulldown enable.
0x0: Disable 100K Ohm Pull Down
0x1: Enable 100K Ohm Pull Down</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RDENA</name>
              <description>read enable.
0x0: Disable Read path on the GPIO
0x1: Enable Read path on the GPIO</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIO3</name>
          <description>GPIO Pin 3 Control</description>
          <addressOffset>0x00000008</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>HWMODE</name>
              <description>hardware mode.
0x0: GPIO Mode. 'GPIO Barium' reads and writes data to the GPIO. Output Enable is controlled by GPIO Barium via the direction bit. Read Enable, Pull-Up, and Pull-Down are controlled by GPIO register in IOCTRLA.
0x1: PWM Mode. 'PWM Barium' writes data to the GPIO.
0x2: LINS RXD which is input of lins_core connects to GPIO output.
0x3: LINS_SEL=0 : LINS RXD; LINS_SEL=1 : Single wire mode, LINS RXD/LINS TXD, Open-drain output.
0x4: Monitor 1st Stage input of LINS RX Glitch filter.
0x5: Monitor 1st Stage output of LINS RX Glitch filter.
0x6: Monitor 2nd Stage output of LINS RX Glitch filter.
0x7: Monitor 3rd Stage output of LINS RX Glitch filter.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LINS_SEL</name>
              <description>LINS Connection Select.
0x0: LINS RXD External input Mode.
0x1: Single wire mode, LINS RXD/LINS TXD, Open-drain output.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PUENA</name>
              <description>pullup enable (active-low).
0x0: Enable 100K Ohm Pull Up
0x1: Disable 100K Ohm Pull Up</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PDENA</name>
              <description>pulldown enable.
0x0: Disable 100K Ohm Pull Down
0x1: Enable 100K Ohm Pull Down</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RDENA</name>
              <description>read enable.
0x0: Disable Read path on the GPIO
0x1: Enable Read path on the GPIO</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIO4</name>
          <description>GPIO Pin 4 Control</description>
          <addressOffset>0x0000000C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>HWMODE</name>
              <description>hardware mode.
0x0: GPIO Mode. 'GPIO Barium' reads and writes data to the GPIO. Output Enable is controlled by GPIO Barium via the direction bit. Read Enable, Pull-Up, and Pull-Down are controlled by GPIO register in IOCTRLA.
0x1: PWM Mode. 'PWM Barium' writes data to the GPIO.
0x2: Testmux Mode. GPIO input connects to LINS TXD.
0x3: LINS CORE TXD Monitor
0x4: Monitor 1st Stage input of LINS RX Glitch filter.
0x5: Monitor 1st Stage output of LINS RX Glitch filter.
0x6: Monitor 2nd Stage output of LINS RX Glitch filter.
0x7: Monitor 3rd Stage output of LINS RX Glitch filter.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PUENA</name>
              <description>pullup enable (active-low).
0x0: Enable 100K Ohm Pull Up
0x1: Disable 100K Ohm Pull Up</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PDENA</name>
              <description>pulldown enable.
0x0: Disable 100K Ohm Pull Down
0x1: Enable 100K Ohm Pull Down</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RDENA</name>
              <description>read enable.
0x0: Disable Read path on the GPIO
0x1: Enable Read path on the GPIO</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LIN</name>
          <description>LIN Pin Control</description>
          <addressOffset>0x00000010</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>LINS_HWMODE</name>
              <description>LIN Slave hardware mode.
0x0: Hardware Mode Disabled. GPIO2 writes/reads the LIN I/O pin.
0x1: Hardware Mode Enabled. LIN peripheral writes/reads the LIN I/O pin.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LINS_PU30K_ENA</name>
              <description>LIN 30K pullup enable.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LINS_TXENA</name>
              <description>LIN transmit enable.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LINS_RXENA</name>
              <description>LIN receive enable. NOTE: The write operation of this register takes effect by IOCTRLA_SFRS-&gt;LIN.UPDATE</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LINS_RXD_HIGH_RST_ENA</name>
              <description>Enable signal that LINs RXD glitch filter at sleep mode is asynchronous reset by high of LINs_RXD. NOTE: The write operation of this register takes effect by configuring
SYSCTRLA_SFRS-&gt;TRIM_ACCESS_KEY.TRIM_ACCESS_KEY, FILT_ACCESS.FILT_UNLOCK and IOCTRLA_SFRS-&gt;LIN.UPDATE</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LINS_SLEEP_GF_THRES0</name>
              <description>LINS RXD glitch filter threshold for 1 to 0, detect '0' width of (T_clk_lf*resetvalue = 4us*3 = 12[us],
NOTE: The write operation of this register takes effect by configuring
SYSCTRLA_SFRS-&gt;TRIM_ACCESS_KEY.TRIM_ACCESS_KEY, FILT_ACCESS.FILT_UNLOCK and IOCTRLA_SFRS-&gt;LIN.UPDATE</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LINS_SLEEP_GF_THRES1</name>
              <description>LINS RXD glitch filter threshold for 0 to 1, detect '1' width of (T_clk_lf*resetvalue = 4us*3 = 12[us],
NOTE: The write operation of this register takes effect by configuring
SYSCTRLA_SFRS-&gt;TRIM_ACCESS_KEY.TRIM_ACCESS_KEY, FILT_ACCESS.FILT_UNLOCK and IOCTRLA_SFRS-&gt;LIN.UPDATE</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LINS_PUOFF_TIMEOUT</name>
              <description>LINS Pullup Disable in dominant TimeOut condition. Set to disable LINS 30K pullup in case that lin bus is shorted to ground(Bus idle dominant timeout is detected) for saving power. LINS Pullup will be recovered automatically if bus idle dominant timeout is released by any bus activity. Only reset by power-on sequence.
NOTE: The write operation of this register takes effect by PMUA_SFRS-&gt;CTRL.UPDATE</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PMODE</name>
              <description>LIN Power Mode. Control LINS power state in hibernate mode.
0x0: Regardless of the related enable bits, LIN TX analog parts will be shut-down in hibernate mode, unless any LIN dominant signal is detected.
0x1: LIN TX analog parts are still controlled by theirs corresponding enable bits.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>UPDATE</name>
              <description>LIN Configure Update. Set to update the Configurations to PRE5V domains.
NOTE: DO NOT change the CTRL register when it is high, which indicates there is an update in progress, It gets cleared by the core when the current update is done</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>dual</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LINSGFCONF</name>
          <description>LINS Glitch Filter Configuration in active mode</description>
          <addressOffset>0x00000014</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>LINSRXGFENA</name>
              <description>LINS RXD Glitch Filter enables.
Bit0: Enable LINS Glitch Filter 3rd stage;
Bit1: Enable LINS Glitch Filter for Sleep Mode.
NOTE: The write operation of this register takes effect by configuring SYSCTRLA_SFRS-&gt;TRIM_ACCESS_KEY.TRIM_ACCESS_KEY, FILT_ACCESS.FILT_UNLOCK</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LINS_RX_GF_ENA_1ST</name>
              <description>LINS RXD 1st Glitch Filter enables. Enable LINS Glitch Filter 1st stage.
NOTE: The write operation of this register takes effect by configuring SYSCTRLA_SFRS-&gt;TRIM_ACCESS_KEY.TRIM_ACCESS_KEY, FILT_ACCESS.FILT_UNLOCK</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LINS_RX_GF_ENA_2ND</name>
              <description>LINS RXD 2nd Glitch Filter enables. Enable LINS Glitch Filter 2nd stage.
NOTE: The write operation of this register takes effect by configuring SYSCTRLA_SFRS-&gt;TRIM_ACCESS_KEY.TRIM_ACCESS_KEY, FILT_ACCESS.FILT_UNLOCK</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LINSDBNCTHRES0</name>
              <description>3rd Stage LINS Debounce Threshold for 1 to 0. 3rd Stage LINS Debounce Threshold for 1 to 0, detect '0' width of (T_clksys*resetvalue = 62.5ns*40 = 2.5[us].
NOTE: The write operation of this register takes effect by configuring SYSCTRLA_SFRS-&gt;TRIM_ACCESS_KEY.TRIM_ACCESS_KEY, FILT_ACCESS.FILT_UNLOCK</description>
              <bitOffset>8</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LINSDBNCTHRES1</name>
              <description>3rd Stage LINS Debounce Threshold for 0 to 1. 3rd Stage LINS Debounce Threshold for 0 to 1, detect '1' width of (T_clksys*resetvalue = 62.5ns*40 = 2.5[us].
NOTE: The write operation of this register takes effect by configuring SYSCTRLA_SFRS-&gt;TRIM_ACCESS_KEY.TRIM_ACCESS_KEY, FILT_ACCESS.FILT_UNLOCK</description>
              <bitOffset>16</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LINTXDMONITOR</name>
          <description>LIN TXD Dominant Timeout</description>
          <addressOffset>0x00000018</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>LINSTXDMONITORENA</name>
              <description>LINS TxD Monitor enable.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LINSTXDTIMEOUTDOMINANT</name>
              <description>Tx Dominant Timeout. The bit is set by LINS TxD monitor if LINS's TxD is stuck at dominant output for 64ms. A dominant to recessive transition of the TxD will clear this bit. LIN's TX will be disabled automatically when this bit is set.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LED</name>
          <description>LED Pin Control</description>
          <addressOffset>0x0000001C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>HWMODE</name>
              <description>LED hardware mode. LED Hardware Mode Enable. Each bit controls the corresponding LED Channel respectively.
0x0: Hardware Mode Disabled. LED_DATA register drives the LED Data Output pin. Read is not available on this pin.
0x1: Hardware Mode Enabled. PWM_BARIUM peripheral drives the LED Data Output pin. Read is not available on this pin.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DATA</name>
              <description>LED Data Out. When the LED hardware mode is disabled, then the data in this register bit is used to drive the LED driver. Each bit controls the corresonding LED Channel respectively.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SENSE_ENA</name>
              <description>LED Forward Voltage Sense Enable. Set to enable LED forward voltage sense module. After setting this bit, it's recommended to wait ~40us before ADC conversion for LED_SENSE to settle down.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SENSE_CTRL</name>
              <description>LED. LED Sense Control bits for override control/debug.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>VFW_ENA</name>
              <description>LED Forward Voltage Current Enable. Set to enable the independent LED VFW current source(maximum=5mA). When ADC CH2 measurement is active, the LED channel selected by CH2_SEL will be driven by LED_VFW current source.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GAIN_SEL</name>
              <description>LED Sense AFE gain select. V_ADC = (vbat-vled)*GAIN , where V_ADC is voltage to ADC LED channle, and GAIN is selected by GAIN_SEL as following:
0x0: GAIN = 0.533
0x1: GAIN = 0.533/2</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PN_OP_START_BIAS_BOOST</name>
              <description>PN OP START BIAS BOOST. PN diff OP start bias current
00: 250nA
01: 500nA
10: 750nA
11: 1uA</description>
              <bitOffset>17</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OP_CHOOSE_R</name>
              <description>LED SENSE OP CHOOSE R. choose nulling resistor to do frequency compensation. Which denpends on the bandwidth of the OP.
R&lt;2:0&gt; R GBW&lt;1:0&gt;(CL=3pF)
000 0.5K 11(10M)
001 2.5K 10(8M) 01(5M)
010 4.5K
011 6.5K 11(3M)
100 8.5K
101 10.5K
110 12.5K
111 14.5K</description>
              <bitOffset>19</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>OP_GBW_SEL</name>
              <description>LED SENSE OP GBW SEL. PN detect fully differential Op GBW choose
00: 3M
01: 5M
10: 8M
11: 10M</description>
              <bitOffset>22</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LED_PULLUP_EN</name>
              <description>LED PULLUP ENABLE. LED PAD Pullup enable, ONE HOT code.
0x1: LED0 PAD pullup to PRE5V through a diode and a 50K resistor
0x2: LED1 PAD pullup to PRE5V through a diode and a 50K resistor
0x4: LED2 PAD pullup to PRE5V through a diode and a 50K resistor</description>
              <bitOffset>24</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ANALOGTESTMUXOVERRIDE</name>
          <description>Analog Testmux Override.This register controls the multiplexers for analog signals.
The select bit allows firmware to control the corresponding select field (in other words, firmware control).
The following table is intended to be a helpful guide in what data should be written to this register in order to connect a source and target together.
Note- Care should be taken to write zero to this register between connection changes. This ensures a clean break between selections.

Data to write at ANALOG_TESTMUX_OVERRIDE to enable connection

Source Description	 Target Description	Data to write to connect Source to Target
3.3V Digital Supply * 1/2	GPIO1	                    0x0000_0107
1.5V Digital Supply	        GPIO1	                    0x0000_0207
VDD_PRE5v * 1/4	                GPIO1	                    0x0000_0407
VBG_1P2V	                GPIO2	                    0x0000_0807
VBG_BUF	                        GPIO2	                    0x0000_1007
VREF_1P1	                GPIO2	                    0x0000_2007
Temperature Sensor	        GPIO2	                    0x0000_4007
ADC_REFP	                GPIO2	                    0x0000_8007
BOR_REF	                        GPIO2	                    0x0001_0007</description>
          <addressOffset>0x00000020</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>GPIOCONSEL</name>
              <description>Hardware/Firmware Select.
0x0: Hardware Controlled.
0x1: GPIO_CON_REG controls output.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ADCCONSEL</name>
              <description>ADC CON SEL.
0x0: Hardware Controlled.
0x1: ADC_CON_REG controls output.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ADCSELSEL</name>
              <description>Hardware/Firmware Select.
0x0: Hardware Controlled.
0x1: ADC_SEL_REG controls output.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPIOCONREG</name>
              <description>Firmware Debug Value. GPIO test MUX select
0x1: Select VDD3V3*1/2 to GPIO1
0x2: Select VDD1V5 to GPIO1
0x4: Select VDD_PRE5V*1/4 to GPIO1
0x8: Select VBG_1P2V to GPIO2
0x10: Select VBG_BUF to GPIO2
0x20: Select VREF_1P1 to GPIO2
0x40: Select tempsensor to GPIO2
0x80: Select ADC_REFP to GPIO2
0x100: Select BOR_REF from GPIO2, for BOR trig point test</description>
              <bitOffset>8</bitOffset>
              <bitWidth>9</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ADCCONREG</name>
              <description>Firmware Debug Value. Contains the output value when the ADC_CON_SEL firmware select bit is set
0x1: Select LED0 Forward Voltage for measurement
0x2: Select LED1 Forward Voltage for measurement
0x4: Select LED2 Forward Voltage for measurement</description>
              <bitOffset>20</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>ADCSELREG</name>
              <description>Firmware Debug Value. need to be configured TOGETHER WITH GPIO_CON_REG to enable GPIO0/1 PAD output. (ADC_SEL_SEL also need to be set to 1)
0x1: Enable GPIO0 analog connection to ADC
0x2: Enable GPIO1 analog connection to ADC
0x4: Enable GPIO2 analog connection to ADC
0x8: Enable GPIO3 analog connection to ADC</description>
              <bitOffset>24</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LEDSEL</name>
              <description>Firmware Debug Value.
0x1: Enable LED0 analog connection for short to gnd detecting
0x2: Enable LED1 analog connection for short to gnd detecting
0x4: Enable LED2 analog connection for short to gnd detecting</description>
              <bitOffset>28</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>IRQ</name>
          <description>IOCTRLA LINS TXD Dominant Monitor interrupts</description>
          <addressOffset>0x00000024</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>LINS_TXD_DOM_ENABLE</name>
              <description>LINS TXD Dominant Monitor interrupt enable.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LINS_TXD_DOM_CLEAR</name>
              <description>LINS TXD Dominant Monitor interrupt clear.
Autoclear: includes a synchronous reset signal which clears the register on the cycle following write.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>LINS_TXD_DOM_STATUS</name>
              <description>LINS TXD Dominant Monitor interrupt status.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>LINS_TXD_DOM_ACTIVE</name>
              <description>LINS TXD Dominant Monitor interrupt active.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LINSGFCONF1</name>
          <description>LINS Glitch Filter Configuration in active mode</description>
          <addressOffset>0x00000028</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>LINS_DBNC_THRES0_1ST</name>
              <description>1st Stage LINS Debounce Threshold for 1 to 0. 1st Stage LINS Debounce Threshold for 1 to 0, detect '0' width of (T_clksys*resetvalue = 62.5ns*8 = 0.5[us]).
NOTE: The write operation of this register takes effect by configuring SYSCTRLA_SFRS-&gt;TRIM_ACCESS_KEY.TRIM_ACCESS_KEY, FILT_ACCESS.FILT_UNLOCK</description>
              <bitOffset>0</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LINS_DBNC_THRES1_1ST</name>
              <description>1st Stage LINS Debounce Threshold for 0 to 1. 1st Stage LINS Debounce Threshold for 0 to 1, detect '1' width of (T_clksys*resetvalue = 62.5ns*0 = 0[us]).
NOTE: The write operation of this register takes effect by configuring SYSCTRLA_SFRS-&gt;TRIM_ACCESS_KEY.TRIM_ACCESS_KEY, FILT_ACCESS.FILT_UNLOCK</description>
              <bitOffset>8</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LINS_DBNC_THRES0_2ND</name>
              <description>2nd Stage LINS Debounce Threshold for 1 to 0. 2nd Stage LINS Debounce Threshold for 1 to 0, detect '0' width of (T_clksys*resetvalue = 62.5ns*16 = 1[us]).
NOTE: The write operation of this register takes effect by configuring SYSCTRLA_SFRS-&gt;TRIM_ACCESS_KEY.TRIM_ACCESS_KEY, FILT_ACCESS.FILT_UNLOCK</description>
              <bitOffset>16</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LINS_DBNC_THRES1_2ND</name>
              <description>2nd Stage LINS Debounce Threshold for 0 to 1. 2nd Stage LINS Debounce Threshold for 0 to 1, detect '1' width of (T_clksys*resetvalue = 62.5ns*32 = 2[us]).
NOTE: The write operation of this register takes effect by configuring SYSCTRLA_SFRS-&gt;TRIM_ACCESS_KEY.TRIM_ACCESS_KEY, FILT_ACCESS.FILT_UNLOCK</description>
              <bitOffset>24</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FILT_ACCESS</name>
          <description>Glitch Filter access key</description>
          <addressOffset>0x0000002C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>FILT_UNLOCK</name>
              <description>Set Only bit. Write 1 to this bit to un-lock FILT_CODE bits.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>IOCAPTURE</name>
          <description>IO capture controller</description>
          <addressOffset>0x00000030</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>CAPENA</name>
              <description>IO capture enable. enable io capture.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IRQENA</name>
              <description>IO capture irq enable. enable io capture irq, gpio posedge or io capture counter exceeds the threshold will trigger interrupt.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IRQCLR</name>
              <description>IO capture irq clear. clear io capture irq.
Autoclear: includes a synchronous reset signal which clears the register on the cycle following write.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IRQSTS</name>
              <description>IO capture irq status. io capture irq status.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>PRESCALE_EN</name>
              <description>prescale enable. prescale enable.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRESCALE</name>
              <description>prescaler select.
0x0: Divide by 1.
0x1: Divide by 2
0x2: Divide by 4
0x3: Divide by 8</description>
              <bitOffset>17</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>IOCAPTUREPERIOD0</name>
          <addressOffset>0x00000034</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>PERIOD_GPIO0</name>
              <description>GPIO0 input signal period. GPIO0 input signal period.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PERIOD_GPIO1</name>
              <description>GPIO1 input signal period. GPIO1 input signal period.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>IOCAPTUREPERIOD1</name>
          <addressOffset>0x00000038</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>PERIOD_GPIO2</name>
              <description>GPIO2 input signal period. GPIO2 input signal period.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PERIOD_GPIO3</name>
              <description>GPIO3 input signal period. GPIO3 input signal period.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>COUNTERGPIO0</name>
          <addressOffset>0x0000003C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>COUNTER_HIGH_GPIO0</name>
              <description>GPIO0 input high level counter. GPIO0 input high level counter, the high level width is equal to the counter plus 1.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>COUNTER_LOW_GPIO0</name>
              <description>GPIO0 input low level counter. GPIO0 input low level counter, the low level width is equal to the counter plus 1.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>COUNTERGPIO1</name>
          <addressOffset>0x00000040</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>COUNTER_HIGH_GPIO1</name>
              <description>GPIO1 input high level counter. GPIO1 input high level counter, the high level width is equal to the counter plus 1.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>COUNTER_LOW_GPIO1</name>
              <description>GPIO1 input low level counter. GPIO1 input low level counter, the low level width is equal to the counter plus 1.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>COUNTERGPIO2</name>
          <addressOffset>0x00000044</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>COUNTER_HIGH_GPIO2</name>
              <description>GPIO2 input high level counter. GPIO2 input high level counter, the high level width is equal to the counter plus 1.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>COUNTER_LOW_GPIO2</name>
              <description>GPIO2 input low level counter. GPIO0 input low level counter, the low level width is equal to the counter plus 1.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>COUNTERGPIO3</name>
          <addressOffset>0x00000048</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>COUNTER_HIGH_GPIO3</name>
              <description>GPIO3 input high level counter. GPIO3 input high level counter.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>COUNTER_LOW_GPIO3</name>
              <description>GPIO3 input low level counter. GPIO3 input low level counter.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>IOGFCONF</name>
          <description>IO capture Glitch Filter Configuration in active mode</description>
          <addressOffset>0x0000004C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>IO_DBNC_THRES0</name>
              <description>IO Debounce Threshold for 1 to 0. IO Debounce Threshold for 1 to 0, detect '0' width of (T_clksys*resetvalue = 62.5ns*8 = 0.5[us]).
NOTE: The write operation of this register takes effect by configuring SYSCTRLA_SFRS-&gt;TRIM_ACCESS_KEY.TRIM_ACCESS_KEY, FILT_ACCESS.FILT_UNLOCK</description>
              <bitOffset>0</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>IO_DBNC_THRES1</name>
              <description>IO Debounce Threshold for 0 to 1. IO Debounce Threshold for 0 to 1, detect '1' width of (T_clksys*resetvalue = 62.5ns*8 = 0.5[us]).
NOTE: The write operation of this register takes effect by configuring SYSCTRLA_SFRS-&gt;TRIM_ACCESS_KEY.TRIM_ACCESS_KEY, FILT_ACCESS.FILT_UNLOCK</description>
              <bitOffset>8</bitOffset>
              <bitWidth>7</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>SYSCTRLA</name>
      <version>B0</version>
      <description>System configuration and retention memory</description>
      <groupName>SYSCTRLA</groupName>
      <prependToName>SYSCTRLA_</prependToName>
      <baseAddress>0x50012000 </baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x2000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>RETAIN0</name>
          <description>Retained data 0</description>
          <addressOffset>0x00000000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>RETAIN0</name>
              <description>Firmware scratch register 0. Only reset at power-on (e.g contents retained in Hibernate mode and retained despite any hard or soft resets). NOTE: The write operation of this register takes effect by PMU_SFRS-&gt;CTRL.UPDATE</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>dual</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RETAIN1</name>
          <description>Retained data 1</description>
          <addressOffset>0x00000004</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>RETAIN1</name>
              <description>Firmware scratch register 1 (0x1). Contents retained in Hibernate mode - but lost after any hard or soft reset.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DEBUG_ACCESS_KEY</name>
          <description>Debug access key</description>
          <addressOffset>0x00000008</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>DEBUG_ACCESS_KEY</name>
              <description>Write the value 0x5 to this register to enable debug options. Write any other value to disable the debug options.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>DEBUG_LOCK</name>
              <description>Set Only bit. Set this bit to lock DEBUG_CODE bits.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DEBUG_ACCESS_ENABLED</name>
          <description>Debug access enabled</description>
          <addressOffset>0x0000000C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>DEBUG_ACCESS_ENABLED</name>
              <description>A status flag that is set when debug access is enabled</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TRIM_ACCESS_KEY</name>
          <description>Trim access key</description>
          <addressOffset>0x00000010</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>TRIM_ACCESS_KEY</name>
              <description>Write the value 0xe to this register to enable 'trim access' (which allows write access to various trim settings and production test options). Write any other value to disable trim access.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIM_LOCK</name>
              <description>Set Only bit. Write 1 to this bit to lock TRIM_CODE bits.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TRIM_ACCESS_ENABLED</name>
          <description>Trim access enabled</description>
          <addressOffset>0x00000014</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>TRIM_ACCESS_ENABLED</name>
              <description>A status flag that is set when trim access is enabled</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMU_ACCESS_KEY</name>
          <description>PMU configure access key</description>
          <addressOffset>0x00000018</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>PMU_ACCESS_KEY</name>
              <description>Write the value 0xA to this register to enable 1v5 domain at hibernate. Write any other value to disable the 1v5 domain at hibernate.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>4</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PMU_LOCK</name>
              <description>Set Only bit. Set this bit to lock PMU_CODE bits.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PMU_ACCESS_ENABLED</name>
          <description>PMU configure access enabled</description>
          <addressOffset>0x0000001C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>PMU_ACCESS_ENABLED</name>
              <description>A status flag that is set when pmu access is enabled</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LF_OSC_TRIM</name>
          <description>Trim controls for the low frequency (32k/250KHz) oscillators</description>
          <addressOffset>0x00000020</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>TRIM_LF_RC</name>
              <description>LF RC oscillator trim. Following value only used as a reference:
NOTE: The write operation of this register takes effect by PMU_SFRS-&gt;CTRL.UPDATE and write trim key
0x0: freq=141.1KHz
0x9b: freq=250.0KHz
0xa0: freq=256.0KHz
0xff: freq=441.7KHz</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HF_OSC_TRIM</name>
          <description>Trim controls for the high frequency (16MHz) oscillator</description>
          <addressOffset>0x00000024</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>TRIM_HF_RC</name>
              <description>High Frequency RC Oscillator trim. TRIM bits will be changed if SSC is enabled. Reload the trim bits from Flash if SSC is disabled while the change has happened.write trim key. Following value only used as a reference:
0x0: freq= 9MHz
0xa7: freq=16MHz
0xff: freq=35MHz</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SSCENA</name>
              <description>SSC Enable.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SSCDEEP</name>
              <description>SSC Depth Configuration.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SSCDIV</name>
              <description>SSC Clock Divider. SSC Freq = SYS_FREQ/[(SSC_DIV+1)*(SSC_DEEP+1)*4].</description>
              <bitOffset>16</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>BIAS</name>
          <description>Bias Control</description>
          <addressOffset>0x00000028</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>LEDBIASSEL</name>
              <description>High Voltage LED bias select.
0x0: The LED Bias is enabled and disabled by the pmu hardware state machine by default.
0x1: The value of the LED_BIAS_REG field is what is used to drive the LED_BIAS signal. (override mode)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LEDBIASREG</name>
              <description>High Voltage LED bias select register. If LED_BIAS_SEL is set, then LED_BIAS_REG allows override access to the LED BIAS signal.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TRIMLEDBIAS</name>
          <description>LED bias current Trim</description>
          <addressOffset>0x0000002C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>LEDBIASTRIM</name>
              <description>LED bias current trim. each code is about 50nA step.wirte trim key</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TRIMLED0</name>
          <description>High Voltage LED trim</description>
          <addressOffset>0x00000030</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>TRIM0</name>
              <description>LED trim (120uA step; max about 60mA).</description>
              <bitOffset>16</bitOffset>
              <bitWidth>9</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TRIMLED1</name>
          <description>High Voltage LED trim</description>
          <addressOffset>0x00000034</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>TRIM1</name>
              <description>LED trim (120uA step; max about 60mA).</description>
              <bitOffset>16</bitOffset>
              <bitWidth>9</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TRIMLED2</name>
          <description>High Voltage LED trim</description>
          <addressOffset>0x00000038</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>TRIM2</name>
              <description>LED trim (120uA step; max about 60mA).</description>
              <bitOffset>16</bitOffset>
              <bitWidth>9</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TRIMVFW</name>
          <description>VFW Current Trim</description>
          <addressOffset>0x0000003C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>TRIMVFW</name>
              <description>PN Forward Voltage Current trim (10uA step max about 2.56mA).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LIN</name>
          <description>LIN IO Control (Trim access need to be enabled before Written)</description>
          <addressOffset>0x00000040</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>LINS_TX_SLOPE</name>
              <description>boost TX driver slew rate of LIN_IN,Slew from 40%*Vbat to 60%*Vbat @Vbat=13V,Cbus=1nF.The write operation of this register takes effect by PMU_SFRS-&gt;CTRL.UPDATE and wirte trim key
0x0: slewRate_pos = 0.62V/us, slewRate_neg = 0.63V/us
0x1: slewRate_pos = 0.62V/us, slewRate_neg = 0.63V/us
0x2: slewRate_pos = 1.19V/us, slewRate_neg = 1.27V/us
0x3: slewRate_pos = 1.74V/us, slewRate_neg = 1.88V/us
0x4: slewRate_pos = 2.31V/us, slewRate_neg = 2.42V/us
0x5: slewRate_pos = 2.79V/us, slewRate_neg = 2.99V/us
0x6: slewRate_pos = 3.37V/us, slewRate_neg = 3.51V/us
0x7: slewRate_pos = 5.14V/us, slewRate_neg = 16.69V/us</description>
              <bitOffset>0</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LINS_TX_BIAS_BOOST</name>
              <description>Select boost of LIN Slave TX IO Current, it should be within 40mA ~ 200mA.The write operation of this register takes effect by PMU_SFRS-&gt;CTRL.UPDATE and wirte trim key
0x0: 31.4 mA
0x1: 48.6 mA
0x2: 66.2 mA
0x3: 88.2 mA
0x4: 101.2 mA
0x5: 117.9 mA
0x6: 135.2 mA
0x7: 151.5 mA</description>
              <bitOffset>8</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LINS_RX_BIAS_BOOST</name>
              <description>adjust rise delay from LIN_IN to Input of LINS Controller.The write operation of this register takes effect by PMU_SFRS-&gt;CTRL.UPDATE and wirte trim key
0x0: 2.323 us
0x1: 1.344 us
0x2: 0.968 us
0x3: 0.767 us</description>
              <bitOffset>12</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>LINS_TX_DUTY</name>
              <description>LIN Slave IO Duty cycle adjust.The write operation of this register takes effect by PMU_SFRS-&gt;CTRL.UPDATE and wirte trim key
0x0: duty cycle = 0.488
0x1: duty cycle = 0.492
0x2: duty cycle = 0.494
0x3: duty cycle = 0.495
0x0: duty cycle = 0.497
0x1: duty cycle = 0.500
0x2: duty cycle = 0.507
0x3: duty cycle = 0.529</description>
              <bitOffset>24</bitOffset>
              <bitWidth>3</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DFTCODE</name>
          <description>DFT Unlock Code</description>
          <addressOffset>0x00000044</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>DFTCODE</name>
              <description>Test Mode Unlock Enable Code. 0x1C needs to be written to this register to unlock the DFT_TESTMODE_SEL and DFT_TESTMODE_START registers.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>8</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>DFT_LOCK</name>
              <description>Set Only bit. Write 1 to this bit to lock DFT related config bits.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DFT_ACCESS_ENABLED</name>
          <description>DFT access enabled</description>
          <addressOffset>0x00000048</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>DFT_ACCESS_ENABLED</name>
              <description>A status flag that is set when DFT access is enabled.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DFTTESTMODESTART</name>
          <description>DFT Mode Start</description>
          <addressOffset>0x0000004C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>DFTTESTMODESTART</name>
              <description>Puts the ASIC into DFT testmode. Once the start bit is set, the I/O configuration will switch from Application mode to DFT Test Mode. The General Purpose I/Os will be configured as a JTAG interface. Once Test Mode is enabled, the ASIC will be boundary terminated and the processor will lose the ability to communicate with any ASIC peripherals. A chip power cycle is required to get out of the DFT test mode. Test Mode Enable state.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NAME</name>
          <description>ASIC name</description>
          <addressOffset>0x00000050</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>NAME</name>
              <description>ASIC name. A read from this register will return the ASIC name</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>REV</name>
          <description>Silicon Revision</description>
          <addressOffset>0x00000054</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>REV</name>
              <description>Silicon Revision. A read from this register will return the ASCII silicon revision (e.g. ASCII C0 is 0x4331)</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>BORTESTMODE</name>
          <description>BOR Testmode Enable</description>
          <addressOffset>0x00000058</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>ENABORTESTMODE</name>
              <description>BOR Testmode Enable.
0x0: BOR Testmode Disabled: Reference Voltage for BOR is from Band Gap (Functional Mode)
0x1: BOR Testmode Enabled: Reference Voltage for BOR is from gpio1_anaOut (Test Mode</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>GPIO</name>
      <version>B0</version>
      <description>GPIO bit control and configuration</description>
      <groupName>GPIO</groupName>
      <prependToName>GPIO_</prependToName>
      <baseAddress>0x50018000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x8000</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>GPADATA</name>
          <description>GPIO Port A Data</description>
          <addressOffset>0x00000000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>GPADATA&lt;1024&gt;</name>
              <description>Port A data. To aid in the efficiency of software, the GPIO ports allow for the modification of individual bits in the GPIO Data by using bits [7:0] of the address bus as a enable. In this manner, software drivers can modify individual GPIO pins in a single instruction without affecting the state of the other pins. This method is more efficient than the conventional method of performing a read-modify-write operation to set or clear an individual GPIO pin. To write all the bits at the same time use address offset of 0x03.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>5</bitWidth>
              <access>dual</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPENA</name>
          <description>GPIO Port Enables</description>
          <addressOffset>0x00000800</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>GPAENA</name>
              <description>Enables the Clock-Gate, can be cleared to save power, if none of the GPIO functionality is required</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPAP03</name>
          <description>GPIO Port A Pin 0-3 Control</description>
          <addressOffset>0x00001000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>GPADIR[0]</name>
              <description>GPIO1 PIN output enable.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPAIE[0]</name>
              <description>GPIO1 PIN interrupt mask.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPARE[0]</name>
              <description>GPIO1 PIN rising edge enable.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPAFE[0]</name>
              <description>GPIO1 PIN falling edge enable.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPACLR[0]</name>
              <description>GPIO1 PIN interrupt clear.
Autoclear: includes a synchronous reset signal which clears the register on the cycle following write.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>GPAACTDET[0]</name>
              <description>GPIO1 PIN activity interrupt.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>GPAACTDETRE[0]</name>
              <description>GPIO1 PIN activity rise status.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>GPAACTDETFE[0]</name>
              <description>GPIO1 PIN activity fall status.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>GPADIR[1]</name>
              <description>GPIO2 PIN output enable.</description>
              <bitOffset>8</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPAIE[1]</name>
              <description>GPIO2 PIN interrupt mask.</description>
              <bitOffset>9</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPARE[1]</name>
              <description>GPIO2 PIN rising edge enable.</description>
              <bitOffset>10</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPAFE[1]</name>
              <description>GPIO2 PIN falling edge enable.</description>
              <bitOffset>11</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPACLR[1]</name>
              <description>GPIO2 PIN interrupt clear.
Autoclear: includes a synchronous reset signal which clears the register on the cycle following write.</description>
              <bitOffset>12</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>GPAACTDET[1]</name>
              <description>GPIO2 PIN activity interrupt.</description>
              <bitOffset>13</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>GPAACTDETRE[1]</name>
              <description>GPIO2 PIN activity rise status.</description>
              <bitOffset>14</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>GPAACTDETFE[1]</name>
              <description>GPIO2 PIN activity fall status.</description>
              <bitOffset>15</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>GPADIR[2]</name>
              <description>NOT USED. SEE IOCTRL RxLIN_ena &amp; TxLIN_ena.</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPAIE[2]</name>
              <description>LIN_IN PIN interrupt mask.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPARE[2]</name>
              <description>LIN_IN PIN rising edge enable.</description>
              <bitOffset>18</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPAFE[2]</name>
              <description>LIN_IN PIN falling edge enable.</description>
              <bitOffset>19</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPACLR[2]</name>
              <description>LIN_IN PIN interrupt clear.
Autoclear: includes a synchronous reset signal which clears the register on the cycle following write.</description>
              <bitOffset>20</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>GPAACTDET[2]</name>
              <description>LIN_IN PIN activity interrupt.</description>
              <bitOffset>21</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>GPAACTDETRE[2]</name>
              <description>LIN_IN PIN activity rise status.</description>
              <bitOffset>22</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>GPAACTDETFE[2]</name>
              <description>LIN_IN PIN activity fall status.</description>
              <bitOffset>23</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>GPADIR[3]</name>
              <description>GPIO3 PIN output enable.</description>
              <bitOffset>24</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPAIE[3]</name>
              <description>GPIO3 PIN interrupt mask.</description>
              <bitOffset>25</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPARE[3]</name>
              <description>GPIO3 PIN rising edge enable.</description>
              <bitOffset>26</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPAFE[3]</name>
              <description>GPIO3 PIN falling edge enable.</description>
              <bitOffset>27</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPACLR[3]</name>
              <description>GPIO3 PIN interrupt clear.
Autoclear: includes a synchronous reset signal which clears the register on the cycle following write.</description>
              <bitOffset>28</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>GPAACTDET[3]</name>
              <description>GPIO3 PIN activity interrupt.</description>
              <bitOffset>29</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>GPAACTDETRE[3]</name>
              <description>GPIO3 PIN activity rise status.</description>
              <bitOffset>30</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>GPAACTDETFE[3]</name>
              <description>GPIO3 PIN activity fall status.</description>
              <bitOffset>31</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPAP4</name>
          <description>GPIO Port A Pin 4 Control</description>
          <addressOffset>0x00001004</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>GPADIR[4]</name>
              <description>GPIO4 PIN output enable.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPAIE[4]</name>
              <description>GPIO4 PIN interrupt mask.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPARE[4]</name>
              <description>GPIO4 PIN rising edge enable.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPAFE[4]</name>
              <description>GPIO4 PIN falling edge enable.</description>
              <bitOffset>3</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>GPACLR[4]</name>
              <description>GPIO4 PIN interrupt clear.
Autoclear: includes a synchronous reset signal which clears the register on the cycle following write.</description>
              <bitOffset>4</bitOffset>
              <bitWidth>1</bitWidth>
              <access>write-only</access>
            </field>
            <field>
              <name>GPAACTDET[4]</name>
              <description>GPIO4 PIN activity interrupt.</description>
              <bitOffset>5</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>GPAACTDETRE[4]</name>
              <description>GPIO4 PIN activity rise status.</description>
              <bitOffset>6</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
            <field>
              <name>GPAACTDETFE[4]</name>
              <description>GPIO4 PIN activity fall status.</description>
              <bitOffset>7</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>TIMER0</name>
      <version>B0</version>
      <description>General purpose timer 0 registers</description>
      <groupName>TIMER0</groupName>
      <prependToName>TIMER0_</prependToName>
      <baseAddress>0x50020000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x0008</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>COUNT</name>
          <description>Timer Counter Register</description>
          <addressOffset>0x00000000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>COUNT</name>
              <description>Count. Initial counter value. The timer will count from this value to 0xFFFFFFFF and roll over to 0x00000000. At this point it will generate an interrupt if enabled. The interrupt routine is responsible for reloading the value if needed as this timer does not auto-reload the original content.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CFG</name>
          <description>Timer Control Register</description>
          <addressOffset>0x00000004</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>ENA</name>
              <description>Enable. This bit starts/stops the timer: &lt; br&gt; 1 = Timer Running &lt; br&gt; 0 = Timer Inactive</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>TIMER1</name>
      <version>B0</version>
      <description>General purpose timer 1 registers</description>
      <groupName>TIMER1</groupName>
      <prependToName>TIMER1_</prependToName>
      <baseAddress>0x50020008</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x0008</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>COUNT</name>
          <description>Timer Counter Register</description>
          <addressOffset>0x00000000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>COUNT</name>
              <description>Count. Initial counter value. The timer will count from this value to 0xFFFFFFFF and roll over to 0x00000000. At this point it will generate an interrupt if enabled. The interrupt routine is responsible for reloading the value if needed as this timer does not auto-reload the original content.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CFG</name>
          <description>Timer Control Register</description>
          <addressOffset>0x00000004</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>ENA</name>
              <description>Enable. This bit starts/stops the timer: &lt; br&gt; 1 = Timer Running &lt; br&gt; 0 = Timer Inactive</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>TIMER2</name>
      <version>B0</version>
      <description>General purpose timer 2 registers</description>
      <groupName>TIMER2</groupName>
      <prependToName>TIMER2_</prependToName>
      <baseAddress>0x50020010</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x0008</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>COUNT</name>
          <description>Timer Counter Register</description>
          <addressOffset>0x00000000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>COUNT</name>
              <description>Count. Initial counter value. The timer will count from this value to 0xFFFFFFFF and roll over to 0x00000000. At this point it will generate an interrupt if enabled. The interrupt routine is responsible for reloading the value if needed as this timer does not auto-reload the original content.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CFG</name>
          <description>Timer Control Register</description>
          <addressOffset>0x00000004</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>ENA</name>
              <description>Enable. This bit starts/stops the timer: &lt; br&gt; 1 = Timer Running &lt; br&gt; 0 = Timer Inactive</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>WDT1</name>
      <version>B0</version>
      <description>The watchdog timer that is local to VERNE MCU</description>
      <groupName>WDT1</groupName>
      <prependToName>WDT1_</prependToName>
      <baseAddress>0x50020018</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x0008</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CFG</name>
          <description>Config</description>
          <addressOffset>0x00000000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>ENA</name>
              <description>WDT Enable. This bit can be asserted but it cannot be de-asserted. It means that once the WDT is enabled it cannot be turned off until a Reset or Power-On Reset occurs.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RSTEN</name>
              <description>Reset enable. If enabled a WDT time-out will force the microcontroller to reset. This bit can be asserted but it cannot be de-asserted.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>RSTFLAG</name>
              <description>Reset flag. This flag is set by the system at the initialization if the initialization was caused by a reset triggered by the WDT. The bit can be cleared by the application.</description>
              <bitOffset>2</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>PRESET</name>
              <description>Preset. Defines the watchdog timeout period.
It means that the WDT internal counter will count from 0 to the prescaler value at the system clock speed and trigger if not cleared. For instance, a system running from a 30MHz Crystal with WDTPRES[1I0] = 10 will trigger the WDT after approximately 0.14 seconds if not cleared properly and in time by the application.
0x0: 2^13 / System Clock
0x1: 2^19 / System Clock
0x2: 2^22 / System Clock
0x3: 2^32 / System Clock</description>
              <bitOffset>3</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>KEY</name>
          <addressOffset>0x00000004</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>KEY</name>
              <description>Key. To clear the WDT counting the following words must be written in this order and without any other instruction between then:
0x3C570001
0x007F4AD6</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>FLASH</name>
      <version>B0</version>
      <description>FLASH Memory registers</description>
      <groupName>FLASH</groupName>
      <prependToName>FLASH_</prependToName>
      <baseAddress>0x50020020</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>0x0040</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>FLADDR</name>
          <description>Destination address for flash write / erase operation</description>
          <addressOffset>0x00000000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>ADDR</name>
              <description>Target address for write/erase operation.
In byte writes, this is the read address of the flash to be written to.
In erase modes, it is a read address inside the sector to be erased.
This register must be written in the correct sequence or the operation will fail.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>17</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FLWRDT</name>
          <description>Flash data to be written</description>
          <addressOffset>0x00000004</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>DATA</name>
              <description>Content to be written into the targeted address.
This register must be written in the correct sequence or the operation will fail.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UNLBWR</name>
          <description>Flash data unlock register</description>
          <addressOffset>0x00000008</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>UNLOCK_WRITE</name>
              <description>Control register to unlock write. A value of 0x55555555 must be written to this address at the correct point in the write sequence or the operation will fail.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>BWRSTRT</name>
          <description>Flash write start register</description>
          <addressOffset>0x0000000C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>WRITE_START</name>
              <description>Control register to start a write. A value of 0xAAAAAAAA must be written to this address at the correct point in the write sequence or the operation will fail.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UNLSER</name>
          <description>Flash sector erase unlock register</description>
          <addressOffset>0x00000010</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>UNLOCK_ERASE</name>
              <description>Control register to unlock a sector erase. A value of 0x66666666 must be written to this address at the correct point in the sector erase sequence or the operation will fail.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SERSTRT</name>
          <description>Flash sector erase start register</description>
          <addressOffset>0x00000014</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>ERASE_START</name>
              <description>Control register to commit a sector erase. A value of 0x99999999 must be written to this address at the correct point in the sector erase sequence or the operation will fail.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FLSCTRL</name>
          <description>Flash control register</description>
          <addressOffset>0x00000020</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>CTRL</name>
              <description>Number of wait states used in the reading process. Each read from flash memory will take number of cycles equal to 1+RWC to complete.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FLSCP</name>
          <description>Flash code protection register</description>
          <addressOffset>0x00000024</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>CODE_PROT</name>
              <description>Code Protection / SerialWire Lockout Control
Code protection control register.
Write a value of 0xF2E11047 to disable the SerialWire interface.
Write 0x00000000 to enable it.
This allows the user program to disable the SerialWire interface to prevent unauthorized debug access to the part.
NOTE1: This register does not lock the Flash Memory against read/write/erase by the applications program. Instead what it does is to disable all communications with the debug interface, therefore preventing any external attack. The application code is still able to modify the flash content.
NOTE2: Upon Power-On Reset or Normal Reset the system disables the communication for a small time interval (8192 clock cycles). If the application needs to be protected it is mandatory to set this register with the appropriate code in the beginning of the initialization process and before the internal hardware enable the debug communication.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FLS_UNLOCK_CTRL_OP</name>
          <description>Flash Unlock Control Operation Register</description>
          <addressOffset>0x00000030</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>UNLOCK_CTRL_OP</name>
              <description>Flash Control Operation Register Unlock value. 0xACDC_1972 needs to be written in this register to unlock the Control Operation Register access. When this register is read, it returns the state of the lock:
0: The Control Operation Register is locked. The Control Operation Register (FLASH_CTRL_OP) cannot be written.
1: The Control Operation Register is unlocked. The Control Operation Register (FLASH_CTRL_OP) can be written.
Note: After each write to the FLASH_CTRL_OP register, the state of the lock is cleared and the pattern needs to be written again to allow a new configuration of the register.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>32</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CTRL_OP</name>
          <description>Flash Control Operation Register</description>
          <addressOffset>0x00000034</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>CHIP</name>
              <description>CHIP bit. This bit is only used during the Erase operation. It allows the system to erase more than one sector.
0: The Erase operation will only erase the sector selected by the FLASH_ADDR register value.
1: The Erase operation will erase the full main array of the flash.</description>
              <bitOffset>0</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SIZE</name>
              <description>SIZE of the write operation. Refer to data sheet for more information of the use of this field.</description>
              <bitOffset>1</bitOffset>
              <bitWidth>2</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TRIM</name>
          <description>Flash Trim Register</description>
          <addressOffset>0x00000038</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <fields>
            <field>
              <name>OSC_TRIM</name>
              <description>Oscillator Trim Value. This register will be automatically populated with the value stored in the NVR sector 1 (@0001_0000).</description>
              <bitOffset>0</bitOffset>
              <bitWidth>16</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SDIO_TIMING_CFG</name>
              <description>SDIO interface timing configuration. This register will be automatically populated with the value stored in the NVR sector 1 (@0001_0000). When set, the SDIO/INT signals are captured on the falling edge of CLK. When cleared, these data are captured on the rising edge of CLK</description>
              <bitOffset>16</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
            <field>
              <name>SLEEPDEEP_CFG</name>
              <description>Deep Sleep VDD_IO configuration. This register will be automatically populated with the value stored in the NVR sector 1 (@0001_0000). When set, the system will NOT be reset if VDD_IO is going away during Deep Sleep mode. Otherwise (0), the system is reset if VDD_IO is removed.</description>
              <bitOffset>17</bitOffset>
              <bitWidth>1</bitWidth>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
  </peripherals>
</device>